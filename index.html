<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Birb Flight Lab</title>
  <style>
    :root {
      --glass-surface: rgba(20, 30, 50, 0.65);
      --glass-border: rgba(255, 255, 255, 0.12);
      --accent-primary: #4cc9f0;
      --text-primary: #f0f6fc;
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      -webkit-user-select: none;
    }

    body {
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background-color: #0a1426;
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      color: var(--text-primary);
    }

    main {
      position: relative;
      width: 100%;
      height: 100%;
    }

    header {
      position: absolute;
      top: 1.5rem;
      left: 0;
      width: 100%;
      text-align: center;
      pointer-events: none;
      z-index: 10;
      font-weight: 300;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      font-size: 0.85rem;
      opacity: 0.8;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    }

    .canvas-wrapper {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    canvas {
      display: block;
      outline: none;
    }

    /* Controls UI */
    .canvas-actions {
      position: absolute;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%);
      z-index: 20;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      padding: 1rem;
      border-radius: 1.5rem;
      background: var(--glass-surface);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid var(--glass-border);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      transition: transform 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
      touch-action: none;
      cursor: grab;
    }

    .canvas-actions:active {
      cursor: grabbing;
    }

    .canvas-actions.is-dragging {
      opacity: 0.9;
      transform: scale(1.02) !important;
      box-shadow: 0 12px 48px rgba(0, 0, 0, 0.5);
    }

    .canvas-actions__tray {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 0.45rem;
    }

    @media (max-width: 32rem) {
      .canvas-actions__tray {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    .canvas-action-button {
      padding: 0;
      width: 2.6rem;
      min-width: 2.6rem;
      min-height: 2.6rem;
      border-radius: 0.85rem;
      background: linear-gradient(145deg, rgba(30, 47, 84, 0.9), rgba(20, 31, 56, 0.78));
      border: 1px solid rgba(158, 196, 255, 0.32);
      color: #f1f5ff;
      font-size: 0.66rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      appearance: none;
      -webkit-appearance: none;
    }

    .canvas-action-button:active {
      transform: scale(0.95);
    }

    .control-metrics {
      margin-top: 0.5rem;
      color: rgba(255, 255, 255, 0.7);
      font-size: 0.7rem;
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      width: 100%;
      pointer-events: none;
    }
  </style>
</head>

<body>
  <main>
    <header>Birb Flight Lab</header>

    <!-- Loading Indicator -->
    <div id="loading-screen" style="position:fixed;top:0;left:0;width:100%;height:100%;background:#0a1426;z-index:9999;display:flex;flex-direction:column;align-items:center;justify-content:center;color:#f0f6fc;font-family:'Inter',system-ui,sans-serif;">
      <div style="text-align:center;">
        <div style="font-size:1.2rem;margin-bottom:1rem;letter-spacing:0.1em;">LOADING BIRB...</div>
        <div id="loading-progress" style="font-size:0.9rem;color:rgba(255,255,255,0.6);margin-bottom:1rem;">Initializing...</div>
        <div id="loading-error" style="font-size:0.85rem;color:#ff6b6b;margin-top:1rem;max-width:80%;display:none;"></div>
      </div>
    </div>

    <div class="canvas-wrapper">
      <canvas id="scene" role="img" aria-label="Stylized blue bird gliding through a dark sky"></canvas>
      <div class="canvas-actions" data-draggable-panel>
        <div class="canvas-actions__tray" role="group" aria-label="Display options">
          <button type="button" class="canvas-action-button" data-control="camera" title="Toggle Camera (FPV)">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
              style="width:1.2rem;height:1.2rem">
              <path d="M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z" />
              <path
                d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7Z" />
            </svg>
          </button>
          <button type="button" class="canvas-action-button" data-control="environment" title="Cycle Environment">
            <svg class="environment-toggle__icon" viewBox="0 0 24 24" aria-hidden="true" focusable="false"
              style="width:1.2rem;height:1.2rem;fill:none;stroke:currentColor;stroke-width:1.5">
              <path d="M12 20.25a8.25 8.25 0 1 0 0-16.5 8.25 8.25 0 0 0 0 16.5Z" />
              <path d="M3.9 9.75h16.2m-16.2 4.5h16.2" />
              <path
                d="M12 3.75c2.3 2.4 3.45 5.4 3.45 8.25S14.3 17.85 12 20.25m0-16.5c-2.3 2.4-3.45 5.4-3.45 8.25S9.7 17.85 12 20.25" />
            </svg>
          </button>
          <button type="button" class="canvas-action-button" data-control="reset" title="Reset Position">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
              style="width:1.2rem;height:1.2rem">
              <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
              <path d="M3 3v5h5" />
            </svg>
          </button>
          <button type="button" class="canvas-action-button" data-control="fullscreen" title="Toggle Fullscreen">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
              style="width:1.2rem;height:1.2rem">
              <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3" />
            </svg>
          </button>
        </div>
        <div class="control-metrics">
          <div style="display:flex; justify-content:space-between;"><span>SPEED</span><span
              data-metric="speed">0.0m/s</span></div>
          <div style="display:flex; justify-content:space-between;"><span>ALTITUDE</span><span
              data-metric="throttle">5.0m</span></div>
        </div>
      </div>
    </div>
  </main>

  <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js",
          "three/": "https://cdn.jsdelivr.net/npm/three@0.161.0/"
        }
      }
  </script>

  <script type="module">
    import * as THREE from "three";
    import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";
    import { SimpleFlightController } from "./src/controls/simple-flight-controller.js";
    import { createCameraState, CAMERA_MODES } from "./src/camera/camera-state.js";
    import { createFloatingThumbstick } from "./src/controls/virtual-thumbstick.js";
    import { createWorldShell, ENVIRONMENT_VARIANTS, getEnvironmentDefinition } from "./src/environment/world-shell.js";
    import { createSpeedTrail, createWingVortices } from "./src/environment/speed-trail.js";

    // ============================================================================
    // MOBILE DIAGNOSTIC LOGGING & LOADING UI
    // ============================================================================
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const loadingScreen = document.getElementById('loading-screen');
    const loadingProgress = document.getElementById('loading-progress');
    const loadingError = document.getElementById('loading-error');

    function mobileLog(message, data) {
      console.log(`[LOG] ${message}`, data || '');
    }

    function mobileError(message, error) {
      console.error(`[ERROR] ${message}`, error || '');
    }

    function updateLoadingProgress(message) {
      mobileLog(message);
      if (loadingProgress) loadingProgress.textContent = message;
    }

    function showLoadingError(message) {
      mobileError(message);
      if (loadingError) {
        loadingError.textContent = message;
        loadingError.style.display = 'block';
      }
    }

    function hideLoadingScreen() {
      mobileLog('Hiding loading screen');
      if (loadingScreen) {
        loadingScreen.style.opacity = '0';
        loadingScreen.style.transition = 'opacity 0.5s ease-out';
        setTimeout(() => {
          loadingScreen.style.display = 'none';
        }, 500);
      }
    }

    mobileLog('Starting initialization');
    updateLoadingProgress('Starting initialization...');

    // ============================================================================
    // DOM ELEMENT SETUP
    // ============================================================================
    const canvasWrapper = document.querySelector(".canvas-wrapper");
    let canvas = document.querySelector("#scene");

    if (!canvasWrapper || !canvas) {
      mobileError('Critical DOM elements not found');
      throw new Error('Canvas or wrapper not found');
    }

    // ============================================================================
    // RENDERER SETUP
    // ============================================================================
    let renderer;
    let glContext;

    // Check WebGL support
    function isWebGLAvailable() {
      try {
        const testCanvas = document.createElement('canvas');
        const context = testCanvas.getContext('webgl') || testCanvas.getContext('experimental-webgl');
        if (context) {
          const glVersion = context.getParameter(context.VERSION);
          const glslVersion = context.getParameter(context.SHADING_LANGUAGE_VERSION);

          // Some mobile browsers return null for VERSION/SHADING_LANGUAGE_VERSION, which later
          // breaks Three.js when it tries to parse the version string. Treat that as unavailable
          // so we can surface a clean error instead of crashing during renderer creation.
          if (typeof glVersion !== 'string' || typeof glslVersion !== 'string') {
            mobileError('WebGL version strings are unavailable', { glVersion, glslVersion });
            return false;
          }

          mobileLog('WebGL is supported', {
            vendor: context.getParameter(context.VENDOR),
            version: glVersion,
            glsl: glslVersion
          });
          return true;
        }
        return false;
      } catch (e) {
        mobileError('WebGL availability check failed', e);
        return false;
      }
    }

    // Some browsers return null from getShaderPrecisionFormat; provide a safe fallback
    function patchShaderPrecisionFormat() {
      try {
        const glProtos = [
          typeof WebGLRenderingContext !== 'undefined' ? WebGLRenderingContext.prototype : null,
          typeof WebGL2RenderingContext !== 'undefined' ? WebGL2RenderingContext.prototype : null
        ].filter(Boolean);

        glProtos.forEach((proto) => {
          if (proto.__shaderPrecisionPatched) return;

          const original = proto.getShaderPrecisionFormat;
          proto.getShaderPrecisionFormat = function (...args) {
            const result = original ? original.apply(this, args) : null;
            if (result) return result;
            return { rangeMin: 127, rangeMax: 127, precision: 23 };
          };

          proto.__shaderPrecisionPatched = true;
        });
      } catch (e) {
        mobileError('Shader precision patch failed', e);
      }
    }

    // Guard against browsers returning null for VERSION/SHADING_LANGUAGE_VERSION
    function patchGetParameter() {
      try {
        const glProtos = [
          typeof WebGLRenderingContext !== 'undefined' ? WebGLRenderingContext.prototype : null,
          typeof WebGL2RenderingContext !== 'undefined' ? WebGL2RenderingContext.prototype : null
        ].filter(Boolean);

        glProtos.forEach((proto) => {
          if (proto.__getParameterPatched) return;

          const original = proto.getParameter;
          proto.getParameter = function (...args) {
            const result = original ? original.apply(this, args) : null;
            const target = args[0];

            if ((target === this.VERSION || target === this.SHADING_LANGUAGE_VERSION) && result == null) {
              mobileError('WebGL getParameter returned null; providing fallback', { target });
              return 'WebGL 1.0 (fallback)';
            }

            return result;
          };

          proto.__getParameterPatched = true;
        });
      } catch (e) {
        mobileError('WebGL getParameter patch failed', e);
      }
    }

    // As an extra safety net for browsers with quirky contexts (notably
    // iOS Safari), patch the canvas getContext flow so every context we hand to
    // Three.js has the defensive getParameter/getShaderPrecisionFormat
    // behaviour baked in.
    function patchCanvasGetContext() {
      try {
        const proto = HTMLCanvasElement?.prototype;
        if (!proto || proto.__webglContextPatched) return;

        const originalGetContext = proto.getContext;
        proto.getContext = function patchedGetContext(type, attributes) {
          const context = originalGetContext ? originalGetContext.call(this, type, attributes) : null;
          if (!context) return context;

          if (!context.__getParameterPatched) {
            const originalGetParameter = context.getParameter ? context.getParameter.bind(context) : null;
            context.getParameter = function (...args) {
              const result = originalGetParameter ? originalGetParameter(...args) : null;
              const target = args[0];

              if ((target === context.VERSION || target === context.SHADING_LANGUAGE_VERSION) && result == null) {
                mobileError('Canvas context getParameter returned null; providing fallback', { target });
                const inferredVersion = type === 'webgl2' ? 'WebGL 2.0 (fallback)' : 'WebGL 1.0 (fallback)';
                return inferredVersion;
              }

              return result;
            };

            context.__getParameterPatched = true;
          }

          if (!context.__shaderPrecisionPatched) {
            const originalPrecision = context.getShaderPrecisionFormat ? context.getShaderPrecisionFormat.bind(context) : null;
            context.getShaderPrecisionFormat = function (...args) {
              const result = originalPrecision ? originalPrecision(...args) : null;
              if (result) return result;
              return { rangeMin: 127, rangeMax: 127, precision: 23 };
            };

            context.__shaderPrecisionPatched = true;
          }

          return context;
        };

        proto.__webglContextPatched = true;
      } catch (e) {
        mobileError('Canvas getContext patch failed', e);
      }
    }

    // Create a patched WebGL context first so Three.js never receives a null
    // VERSION/SHADING_LANGUAGE_VERSION, which can happen on iOS Safari.
    function createPatchedContext(targetCanvas) {
      const contextAttempts = [
        { type: 'webgl2', attributes: { antialias: !isMobile, alpha: true, failIfMajorPerformanceCaveat: false } },
        { type: 'webgl', attributes: { antialias: !isMobile, alpha: true, failIfMajorPerformanceCaveat: false } },
        { type: 'experimental-webgl', attributes: { alpha: true, failIfMajorPerformanceCaveat: false } }
      ];

      for (const attempt of contextAttempts) {
        try {
          mobileLog(`Attempting to acquire ${attempt.type} context`);
          const context = targetCanvas.getContext(attempt.type, attempt.attributes);
          if (!context) continue;

          if (!context.__getParameterPatched) {
            const originalGetParameter = context.getParameter.bind(context);
            context.getParameter = function (...args) {
              const result = originalGetParameter(...args);
              const target = args[0];
              if ((target === context.VERSION || target === context.SHADING_LANGUAGE_VERSION) && result == null) {
                mobileError('Context getParameter returned null; providing fallback', { target, type: attempt.type });
                const inferredVersion = attempt.type === 'webgl2' ? 'WebGL 2.0 (fallback)' : 'WebGL 1.0 (fallback)';
                return inferredVersion;
              }
              return result;
            };
            context.__getParameterPatched = true;
          }

          if (!context.__shaderPrecisionPatched) {
            const originalPrecision = context.getShaderPrecisionFormat?.bind(context);
            context.getShaderPrecisionFormat = function (...args) {
              const result = originalPrecision ? originalPrecision(...args) : null;
              if (result) return result;
              return { rangeMin: 127, rangeMax: 127, precision: 23 };
            };
            context.__shaderPrecisionPatched = true;
          }

          return context;
        } catch (contextError) {
          mobileError(`Context acquisition for ${attempt.type} failed`, contextError);
        }
      }

      return null;
    }

    try {
      updateLoadingProgress('Checking WebGL support...');

      // Ensure any capability checks see the defensive fallbacks
      patchCanvasGetContext();
      patchGetParameter();

      if (!isWebGLAvailable()) {
        throw new Error('WebGL is not supported on this device');
      }

      updateLoadingProgress('Creating WebGL renderer...');

      // Guard against null getShaderPrecisionFormat on some mobile browsers
      patchShaderPrecisionFormat();
      // Guard against null VERSION/SHADING_LANGUAGE_VERSION responses
      patchGetParameter();

      // Acquire a context first so we can guarantee patched methods are present
      glContext = createPatchedContext(canvas);
      if (!glContext) {
        throw new Error('Unable to create a WebGL context');
      }

      // Try creating renderer with different options as fallbacks
      let rendererOptions = [
        // First attempt: Standard options for desktop
        {
          canvas,
          context: glContext,
          antialias: !isMobile,
          alpha: true,
          powerPreference: 'high-performance',
          failIfMajorPerformanceCaveat: false,
        },
        // Second attempt: Remove powerPreference (iOS compatibility)
        {
          canvas,
          context: glContext,
          antialias: false,
          alpha: true,
          failIfMajorPerformanceCaveat: false,
        },
        // Third attempt: Minimal options
        {
          canvas,
          context: glContext,
          alpha: false,
          failIfMajorPerformanceCaveat: false,
        }
      ];

      let lastError = null;
      for (let i = 0; i < rendererOptions.length; i++) {
        try {
          mobileLog(`Attempting renderer creation with option set ${i + 1}`);
          renderer = new THREE.WebGLRenderer(rendererOptions[i]);
          mobileLog(`Renderer created successfully with option set ${i + 1}`);
          break;
        } catch (e) {
          lastError = e;
          mobileError(`Renderer creation attempt ${i + 1} failed`, e);
          if (i === rendererOptions.length - 1) {
            throw lastError;
          }
        }
      }

      const maxPixelRatio = isMobile ? 1.5 : 2.0;
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, maxPixelRatio));

      // Initial size
      const rect = canvasWrapper.getBoundingClientRect();
      renderer.setSize(rect.width, rect.height, false);

      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.2;

      mobileLog('Renderer created successfully');
      updateLoadingProgress('WebGL renderer created');
    } catch (error) {
      mobileError('Failed to create renderer', error);
      const errorDetails = error.message || error.toString();
      showLoadingError(`Failed to initialize WebGL: ${errorDetails}. Try closing other tabs or restarting your browser.`);
      throw error;
    }

    // ============================================================================
    // SCENE SETUP
    // ============================================================================
    updateLoadingProgress('Setting up 3D scene...');

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a1426);
    scene.fog = new THREE.Fog(0x0a1426, 10.5, 30);

    // Lighting
    const ambient = new THREE.HemisphereLight(0xd4f1ff, 0x1a2f32, 0.92);
    scene.add(ambient);
    const keyLight = new THREE.DirectionalLight(0xf3f0d2, 1.2);
    keyLight.position.set(7.5, 8.2, 5.2);
    scene.add(keyLight);

    mobileLog('Scene and lighting created');

    // Environment
    let environmentShell = null;
    let speedTrail = null;
    let wingVortices = null;
    let currentEnvIndex = 0;

    function setEnvironment(id) {
      if (environmentShell) environmentShell.dispose(scene, environmentShell.root);

      // Clean up particles
      if (speedTrail) { scene.remove(speedTrail.particles); speedTrail.dispose(); }
      if (wingVortices) { scene.remove(wingVortices.particles); wingVortices.dispose(); }

      const definition = getEnvironmentDefinition(id);
      environmentShell = createWorldShell(scene, { three: THREE, variant: id });

      speedTrail = createSpeedTrail(THREE, id);
      scene.add(speedTrail.particles);

      wingVortices = createWingVortices(THREE);
      scene.add(wingVortices.particles);
    }

    updateLoadingProgress('Creating environment...');
    setEnvironment("forest");
    mobileLog('Environment created');

    function cycleEnvironment() {
      currentEnvIndex = (currentEnvIndex + 1) % ENVIRONMENT_VARIANTS.length;
      setEnvironment(ENVIRONMENT_VARIANTS[currentEnvIndex].id);
    }

    // ============================================================================
    // BIRB MODEL
    // ============================================================================
    updateLoadingProgress('Loading birb model...');

    const birbAnchor = new THREE.Group();
    scene.add(birbAnchor);
    const birbRig = new THREE.Group();
    birbAnchor.add(birbRig);
    const birbModel = new THREE.Group();
    birbRig.add(birbModel);

    const wingRefs = { left: null, right: null };
    let birbModelLoaded = false;

    const gltfLoader = new GLTFLoader();

    mobileLog('Starting GLTF load for birb.glb');

    gltfLoader.load(
      './birb.glb',
      // onLoad - success callback
      (gltf) => {
        mobileLog('GLTF model loaded successfully');
        updateLoadingProgress('Birb model loaded!');

        const modelRoot = gltf.scene;
        modelRoot.position.set(0, -0.2, 0);
        birbModel.add(modelRoot);

        modelRoot.traverse((child) => {
          if (child.isMesh) {
            const name = (child.name || "").toLowerCase();
            if (name.includes("wing")) {
              if (name.includes("left") || name.includes("l_")) wingRefs.left = child;
              else if (name.includes("right") || name.includes("r_")) wingRefs.right = child;
            }
          }
        });

        mobileLog('Wing references found:', { left: !!wingRefs.left, right: !!wingRefs.right });
        birbModelLoaded = true;

        // Hide loading screen after a short delay
        setTimeout(() => {
          hideLoadingScreen();
        }, 500);
      },
      // onProgress callback
      (xhr) => {
        if (xhr.lengthComputable) {
          const percentComplete = (xhr.loaded / xhr.total) * 100;
          const message = `Loading birb model: ${Math.round(percentComplete)}%`;
          updateLoadingProgress(message);
          mobileLog(message);
        } else {
          mobileLog(`Loading birb model: ${xhr.loaded} bytes loaded`);
        }
      },
      // onError callback
      (error) => {
        mobileError('Failed to load birb.glb model', error);
        const errorMsg = `Failed to load birb model. Error: ${error.message || 'Unknown error'}. Please check your network connection and try refreshing the page.`;
        showLoadingError(errorMsg);

        // Still hide loading screen after error is shown so user can see the page
        setTimeout(() => {
          if (loadingScreen) loadingScreen.style.opacity = '0.95'; // Keep it slightly visible with error
        }, 3000);
      }
    );

    birbRig.scale.setScalar(0.5);

    // ============================================================================
    // CONTROLS & GAME LOOP
    // ============================================================================
    updateLoadingProgress('Initializing controls...');

    const flightController = new SimpleFlightController();
    const cameraState = createCameraState({ three: THREE, scene, flightController });
    const camera = cameraState.camera;

    // Set FPV by default
    let currentCameraMode = CAMERA_MODES.FPV;
    cameraState.setMode(currentCameraMode);

    mobileLog('Flight controller and camera initialized');

    // Virtual Thumbstick
    let thumbstickValue = { x: 0, y: 0 };
    createFloatingThumbstick(document.body, {
      onStart: () => {
        mobileLog('Thumbstick started');
      },
      onEnd: () => {
        thumbstickValue = { x: 0, y: 0 };
        mobileLog('Thumbstick ended');
      },
      onChange: (val) => {
        thumbstickValue = val;
      }
    });

    mobileLog('Virtual thumbstick created');

    // Draggable Panel Logic
    const panel = document.querySelector('[data-draggable-panel]');
    let isDragging = false;
    let currentX;
    let currentY;
    let initialX;
    let initialY;
    let xOffset = 0;
    let yOffset = 0;

    if (panel) {
      panel.addEventListener('pointerdown', (e) => e.stopPropagation());
      panel.addEventListener('pointermove', (e) => e.stopPropagation());
      panel.addEventListener('pointerup', (e) => e.stopPropagation());
      panel.addEventListener('touchstart', (e) => e.stopPropagation());
      panel.addEventListener('touchmove', (e) => e.stopPropagation());
      panel.addEventListener('touchend', (e) => e.stopPropagation());

      panel.addEventListener("pointerdown", dragStart);
      window.addEventListener("pointerup", dragEnd);
      window.addEventListener("pointermove", drag);
    }

    function dragStart(e) {
      if (e.target.closest('button')) return;

      initialX = e.clientX - xOffset;
      initialY = e.clientY - yOffset;

      if (e.target === panel || panel.contains(e.target)) {
        isDragging = true;
        panel.classList.add('is-dragging');
      }
    }

    function dragEnd(e) {
      initialX = currentX;
      initialY = currentY;
      isDragging = false;
      if (panel) panel.classList.remove('is-dragging');
    }

    function drag(e) {
      if (isDragging && panel) {
        e.preventDefault();
        currentX = e.clientX - initialX;
        currentY = e.clientY - initialY;

        xOffset = currentX;
        yOffset = currentY;

        setTranslate(currentX, currentY, panel);
      }
    }

    function setTranslate(xPos, yPos, el) {
      el.style.transform = `translate3d(${xPos}px, ${yPos}px, 0)`;
    }

    // UI Events
    const cameraBtn = document.querySelector('[data-control="camera"]');
    if (cameraBtn) {
      cameraBtn.addEventListener('click', () => {
        // Toggle between FPV and FOLLOW
        currentCameraMode = currentCameraMode === CAMERA_MODES.FPV ? CAMERA_MODES.FOLLOW : CAMERA_MODES.FPV;
        cameraState.setMode(currentCameraMode);
        cameraBtn.title = `Toggle Camera (${currentCameraMode})`;
        mobileLog(`Camera mode changed to: ${currentCameraMode}`);
      });
    }

    const envBtn = document.querySelector('[data-control="environment"]');
    if (envBtn) envBtn.addEventListener('click', cycleEnvironment);

    const resetBtn = document.querySelector('[data-control="reset"]');
    if (resetBtn) resetBtn.addEventListener('click', () => {
      flightController.position.set(0, 5, 0);
      flightController.velocity.set(0, 0, 0);
      flightController.quaternion.identity();
      cameraState.reset();
    });

    const fullscreenBtn = document.querySelector('[data-control="fullscreen"]');
    if (fullscreenBtn) {
      fullscreenBtn.addEventListener('click', () => {
        if (!document.fullscreenElement) {
          document.documentElement.requestFullscreen().catch(err => {
            console.log(`Error attempting to enable fullscreen: ${err.message}`);
          });
        } else {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          }
        }
      });
    }

    // Resize
    function updateRendererSize() {
      const rect = canvasWrapper.getBoundingClientRect();
      if (canvas.width !== rect.width || canvas.height !== rect.height) {
        renderer.setSize(rect.width, rect.height, false);
        camera.aspect = rect.width / rect.height;
        camera.updateProjectionMatrix();
      }
    }
    window.addEventListener('resize', updateRendererSize);

    // Loop
    let lastTime = performance.now();

    function renderFrame(time) {
      const deltaTime = Math.min((time - lastTime) / 1000, 0.05);
      lastTime = time;

      updateRendererSize();

      // Physics
      flightController.setInputs(-thumbstickValue.x, -thumbstickValue.y);
      const pose = flightController.update(deltaTime);
      const speed = pose.velocity.length();

      // Visuals
      birbAnchor.position.copy(pose.position);
      birbAnchor.quaternion.copy(pose.quaternion);

      const bankAngle = typeof pose.roll === 'number' ? pose.roll : -thumbstickValue.x * 0.5;
      birbRig.rotation.z = THREE.MathUtils.lerp(birbRig.rotation.z, bankAngle, deltaTime * 6);

      // Camera
      cameraState.update({ pose, delta: deltaTime });

      // Environment
      if (environmentShell && environmentShell.update) environmentShell.update(deltaTime, pose.position);
      if (speedTrail) speedTrail.update(deltaTime, pose.position, pose.velocity, speed);
      if (wingVortices) wingVortices.update(deltaTime, pose.position, pose.quaternion, speed);

      // UI
      const speedEl = document.querySelector('[data-metric="speed"]');
      if (speedEl) speedEl.textContent = `${speed.toFixed(1)}m/s`;
      const altEl = document.querySelector('[data-metric="throttle"]');
      if (altEl) altEl.textContent = `${pose.position.y.toFixed(1)}m`;

      renderer.render(scene, camera);
    }

    updateLoadingProgress('Starting animation loop...');
    renderer.setAnimationLoop(renderFrame);
    mobileLog('Animation loop started - initialization complete (waiting for model to load)');

  </script>
</body>

</html>