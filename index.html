<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Birb Flight Lab</title>
    <meta
      name="description"
      content="Mobile-first Three.js playground for experimenting with gliding birbs."
    />
    <meta name="theme-color" content="#0b0d17" />
    <style>
      :root {
        color-scheme: dark;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        --space-2: clamp(0.75rem, 1.5vw + 0.35rem, 1.1rem);
        --space-3: clamp(1rem, 1.5vw + 0.6rem, 1.5rem);
        --space-4: clamp(1.25rem, 2vw + 0.75rem, 1.9rem);
        --max-width: min(92vw, 42rem);
        --header-size: clamp(0.75rem, 1vw + 0.65rem, 1.1rem);
        --status-size: clamp(0.6rem, 0.7vw + 0.55rem, 0.75rem);
        background-color: #0a1324;
      }

      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        min-height: 100dvh;
        display: flex;
        align-items: stretch;
        justify-content: center;
        background: radial-gradient(circle at 30% 20%, #273d68, #0a1324 68%);
        color: #f6f8ff;
      }

      main {
        width: 100%;
        max-width: var(--max-width);
        display: flex;
        flex-direction: column;
        gap: var(--space-3);
        padding: var(--space-3) var(--space-3) calc(var(--space-3) + 3rem);
      }

      header {
        text-align: center;
        text-transform: uppercase;
        letter-spacing: 0.12em;
        font-size: var(--header-size);
        opacity: 0.75;
      }

      .canvas-wrapper {
        position: relative;
        flex: 1;
        min-height: clamp(18rem, 62vw, 32rem);
        border-radius: 1.5rem;
        overflow: hidden;
        backdrop-filter: blur(16px);
        border: 1px solid rgba(186, 210, 255, 0.12);
        box-shadow: 0 26px 56px rgba(6, 14, 29, 0.6);
        padding-bottom: clamp(2.5rem, 16vw, 5.25rem);
      }

      canvas {
        width: 100%;
        height: 100%;
        display: block;
        background: transparent;
      }

      .control-panel {
        position: absolute;
        top: calc(100% + 0.85rem);
        right: 0;
        display: flex;
        flex-direction: column;
        gap: 0.55rem;
        padding: 0.75rem 0.85rem 0.95rem;
        width: min(16rem, 70vw);
        background: rgba(14, 23, 41, 0.88);
        border-radius: 1rem;
        border: 1px solid rgba(124, 170, 255, 0.22);
        box-shadow: 0 18px 46px rgba(7, 14, 32, 0.55);
        backdrop-filter: blur(18px);
        z-index: 4;
        transform-origin: top right;
        transition: opacity 160ms ease, transform 200ms ease;
      }

      .control-panel.is-collapsed {
        opacity: 0;
        transform: translateY(-0.65rem) scale(0.96);
        pointer-events: none;
      }

      .control-panel h2 {
        margin: 0;
        font-size: 0.72rem;
        text-transform: uppercase;
        letter-spacing: 0.16em;
        opacity: 0.7;
      }

      .control-button {
        appearance: none;
        border: 1px solid rgba(176, 209, 255, 0.36);
        border-radius: 999px;
        padding: 0.45rem 0.95rem;
        font-size: 0.72rem;
        font-weight: 600;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #f3f7ff;
        background: linear-gradient(135deg, rgba(64, 105, 184, 0.55), rgba(26, 44, 92, 0.9));
        box-shadow: inset 0 0 0 1px rgba(32, 62, 124, 0.45);
        cursor: pointer;
        transition: transform 150ms ease, box-shadow 150ms ease, border-color 150ms ease;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
      }

      .control-button[disabled] {
        cursor: not-allowed;
        opacity: 0.6;
        border-color: rgba(176, 209, 255, 0.18);
        box-shadow: none;
      }

      .control-button:focus-visible {
        outline: 2px solid rgba(124, 170, 255, 0.75);
        outline-offset: 2px;
      }

      .control-button:not([disabled]):hover {
        box-shadow: inset 0 0 0 1px rgba(108, 150, 226, 0.6), 0 8px 16px rgba(8, 17, 40, 0.45);
        border-color: rgba(206, 230, 255, 0.72);
        transform: translateY(-1px);
      }

      .control-button:not([disabled]):active {
        transform: translateY(0);
      }

      .control-slider {
        display: grid;
        grid-template-columns: auto minmax(0, 1fr);
        align-items: center;
        gap: 0.4rem 0.6rem;
        font-size: 0.7rem;
        letter-spacing: 0.06em;
        color: rgba(225, 233, 255, 0.85);
      }

      .control-slider label {
        text-transform: uppercase;
      }

      .control-slider input[type="range"] {
        -webkit-appearance: none;
        width: 100%;
        height: 0.3rem;
        border-radius: 999px;
        background: rgba(34, 56, 107, 0.7);
        outline: none;
        position: relative;
      }

      .control-slider input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 1rem;
        height: 1rem;
        border-radius: 50%;
        background: radial-gradient(circle at 30% 30%, #c4dcff, #5f8dff 60%, #2d4fa0 100%);
        border: 1px solid rgba(184, 208, 255, 0.6);
        box-shadow: 0 4px 10px rgba(13, 24, 53, 0.5);
        cursor: pointer;
      }

      .control-slider input[type="range"]::-moz-range-thumb {
        width: 1rem;
        height: 1rem;
        border-radius: 50%;
        background: radial-gradient(circle at 30% 30%, #c4dcff, #5f8dff 60%, #2d4fa0 100%);
        border: 1px solid rgba(184, 208, 255, 0.6);
        box-shadow: 0 4px 10px rgba(13, 24, 53, 0.5);
        cursor: pointer;
      }

      .control-slider output {
        justify-self: end;
        font-variant-numeric: tabular-nums;
        opacity: 0.85;
      }

      .touch-controls {
        position: absolute;
        inset: auto 0 var(--space-2) 0;
        display: none;
        justify-content: center;
        align-items: end;
        padding: 0 var(--space-2);
        pointer-events: none;
        z-index: 3;
      }

      .touch-controls > * {
        pointer-events: auto;
      }

      .thumbstick {
        position: relative;
        width: clamp(5.5rem, 28vw, 7.25rem);
        aspect-ratio: 1;
        border-radius: 50%;
        background: rgba(18, 27, 46, 0.6);
        border: 1px solid rgba(168, 204, 255, 0.32);
        box-shadow: 0 12px 32px rgba(7, 13, 28, 0.55);
        backdrop-filter: blur(18px);
        touch-action: none;
        user-select: none;
      }

      .thumbstick::before {
        content: "";
        position: absolute;
        inset: 18%;
        border-radius: 50%;
        border: 1px solid rgba(182, 214, 255, 0.38);
        background: radial-gradient(circle at 35% 35%, rgba(192, 220, 255, 0.52), rgba(104, 148, 226, 0.4) 60%, rgba(46, 74, 132, 0.24) 100%);
        opacity: 0.55;
      }

      .thumbstick__handle {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 42%;
        aspect-ratio: 1;
        border-radius: 50%;
        background: radial-gradient(circle at 30% 30%, #d8e7ff, #7ba6ff 60%, #345cae 100%);
        border: 1px solid rgba(204, 224, 255, 0.7);
        box-shadow: 0 10px 24px rgba(10, 17, 34, 0.62);
        transform: translate(calc(-50% + var(--thumbstick-offset-x, 0px)), calc(-50% + var(--thumbstick-offset-y, 0px)));
        transition: transform 160ms ease;
      }

      .thumbstick.is-active .thumbstick__handle {
        transition: none;
      }

      .lift-controls {
        display: flex;
        flex-direction: column;
        gap: 0.6rem;
        align-items: center;
        justify-content: center;
      }

      .lift-button {
        appearance: none;
        border: 1px solid rgba(176, 209, 255, 0.36);
        border-radius: 999px;
        padding: 0.4rem 1rem;
        font-size: 0.65rem;
        font-weight: 600;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #f3f7ff;
        background: linear-gradient(135deg, rgba(64, 105, 184, 0.58), rgba(26, 44, 92, 0.9));
        box-shadow: inset 0 0 0 1px rgba(32, 62, 124, 0.45);
        touch-action: none;
        user-select: none;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        min-width: clamp(3.6rem, 18vw, 4.75rem);
        text-align: center;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }

      .lift-button__icon {
        font-size: 1.15rem;
        line-height: 1;
      }

      .lift-button.is-active,
      .lift-button:active {
        box-shadow: inset 0 0 0 1px rgba(118, 162, 230, 0.65), 0 8px 18px rgba(9, 16, 34, 0.55);
        border-color: rgba(206, 230, 255, 0.75);
      }

      .canvas-actions {
        position: absolute;
        inset: var(--space-2) var(--space-2) auto auto;
        z-index: 3;
        padding: 0.55rem;
        border-radius: 1.1rem;
        background: rgba(14, 23, 41, 0.76);
        border: 1px solid rgba(132, 174, 255, 0.3);
        box-shadow: 0 16px 42px rgba(6, 14, 31, 0.55);
        backdrop-filter: blur(18px);
        touch-action: none;
        cursor: grab;
        transition: box-shadow 180ms ease;
      }

      .canvas-actions:is(:hover, :focus-within) {
        box-shadow: 0 20px 46px rgba(7, 15, 34, 0.6);
      }

      .canvas-actions.is-dragging {
        cursor: grabbing;
      }

      .canvas-actions__tray {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 0.45rem;
      }

      .settings-popover {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .canvas-action-button {
        padding: 0;
        width: 2.6rem;
        min-width: 2.6rem;
        min-height: 2.6rem;
        border-radius: 0.85rem;
        background: linear-gradient(145deg, rgba(30, 47, 84, 0.9), rgba(20, 31, 56, 0.78));
        border: 1px solid rgba(158, 196, 255, 0.32);
        color: #f1f5ff;
        font-size: 0.66rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        font-weight: 600;
        cursor: pointer;
        box-shadow: 0 12px 28px rgba(7, 14, 30, 0.55);
        backdrop-filter: blur(18px);
        -webkit-touch-callout: none;
        user-select: none;
        -webkit-user-select: none;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.35rem;
        transition: transform 150ms ease, box-shadow 150ms ease, border-color 150ms ease,
          background 180ms ease;
      }

      .canvas-action-button svg {
        width: 1.1rem;
        height: 1.1rem;
        display: block;
      }

      .settings-toggle__icon,
      .environment-toggle__icon,
      .fullscreen-toggle__icon {
        fill: none;
        stroke: currentColor;
        stroke-width: 1.35;
        stroke-linecap: round;
        stroke-linejoin: round;
      }

      .environment-toggle__icon path:first-of-type {
        stroke-width: 1.25;
      }

      .view-toggle__icon {
        fill: currentColor;
      }

      .canvas-action-button:focus-visible {
        outline: 2px solid rgba(124, 170, 255, 0.75);
        outline-offset: 2px;
      }

      .canvas-action-button:not([disabled]):hover {
        box-shadow: 0 16px 34px rgba(8, 15, 33, 0.6);
        border-color: rgba(198, 224, 255, 0.7);
        background: linear-gradient(145deg, rgba(38, 59, 102, 0.98), rgba(24, 37, 66, 0.88));
      }

      .canvas-action-button:not([disabled]):active {
        transform: translateY(1px);
      }

      .control-toggle,
      .fullscreen-toggle,
      .environment-toggle,
      .view-toggle {
        border-color: rgba(124, 170, 255, 0.28);
      }

      .fullscreen-toggle svg[hidden] {
        display: none;
      }

      .visually-hidden {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      .control-metrics {
        margin-top: 0.35rem;
        padding: 0.6rem 0.75rem;
        border-radius: 0.8rem;
        background: rgba(20, 30, 54, 0.72);
        border: 1px solid rgba(174, 206, 255, 0.2);
        display: flex;
        flex-direction: column;
        gap: 0.45rem;
      }

      .control-metrics__row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 1rem;
        font-size: 0.68rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: rgba(232, 240, 255, 0.92);
      }

      .control-metrics__value {
        font-variant-numeric: tabular-nums;
      }

      .control-metrics__note {
        margin: 0.1rem 0 0;
        font-size: 0.62rem;
        letter-spacing: 0.05em;
        color: rgba(210, 222, 252, 0.78);
      }


      body.is-fullscreen-fallback {
        align-items: stretch;
      }

      body.is-fullscreen-fallback main {
        flex: 1;
        display: flex;
        flex-direction: column;
        max-width: none;
        width: 100vw;
        padding: 0;
      }

      body.is-fullscreen-fallback header {
        display: none;
      }

      .canvas-wrapper:fullscreen,
      .canvas-wrapper:-webkit-full-screen,
      .canvas-wrapper.is-fullscreen-fallback {
        max-width: none;
        width: 100vw;
        height: 100vh;
        height: 100dvh;
        min-height: 100vh;
        min-height: 100dvh;
        border-radius: 0;
        border: none;
        box-shadow: none;
        padding-bottom: clamp(3rem, 14vw, 4.5rem);
      }

      .canvas-wrapper:fullscreen .canvas-actions,
      .canvas-wrapper:-webkit-full-screen .canvas-actions,
      .canvas-wrapper.is-fullscreen-fallback .canvas-actions {
        inset: clamp(0.75rem, 3vw, 1.4rem) clamp(0.75rem, 3vw, 1.4rem) auto auto;
      }


      @media (pointer: coarse) {
        .touch-controls {
          display: grid;
        }
      }

      noscript {
        position: fixed;
        inset: auto 0 0 0;
        padding: 1rem;
        text-align: center;
        font-size: 0.85rem;
        background: rgba(6, 9, 18, 0.92);
        color: #eff2fc;
      }

      @media (min-width: 48rem) {
        main {
          padding-bottom: calc(var(--space-4) + 5.5rem);
        }

        .canvas-wrapper {
          min-height: clamp(24rem, 55vh, 38rem);
          border-radius: 2rem;
          padding-bottom: clamp(2rem, 8vw, 3.5rem);
        }

        .control-panel {
          width: clamp(18rem, 32vw, 20rem);
        }

        .control-panel h2 {
          font-size: 0.75rem;
        }

        .control-slider {
          grid-template-columns: auto minmax(9rem, 1fr) auto;
          column-gap: 0.9rem;
        }

        .control-button {
          font-size: 0.75rem;
        }

        .touch-controls {
          display: none;
        }

        .canvas-actions {
          padding: 0.65rem;
        }

        .canvas-actions__tray {
          gap: 0.55rem;
        }
      }
    </style>
  </head>
  <body>
    <main>
      <header>Birb Flight Lab</header>
      <div class="canvas-wrapper">
        <canvas
          id="scene"
          role="img"
          aria-label="Stylized blue bird gliding through a dark sky"
        ></canvas>
        <div class="canvas-actions" data-draggable-panel>
          <div class="canvas-actions__tray" role="group" aria-label="Display options">
            <div class="settings-popover">
              <button
                type="button"
                class="canvas-action-button control-toggle settings-toggle"
                data-control="panel-toggle"
                aria-pressed="false"
                aria-expanded="false"
                aria-controls="flight-control-panel"
                aria-label="Show flight controls"
              >
                <svg
                  class="settings-toggle__icon"
                  viewBox="0 0 24 24"
                  aria-hidden="true"
                  focusable="false"
                >
                  <path
                    d="M12 8.25a3.75 3.75 0 1 0 0 7.5 3.75 3.75 0 0 0 0-7.5Zm9 3.75a1.2 1.2 0 0 0-.84-1.14l-1.74-.58a7.47 7.47 0 0 0-.68-1.66l.87-1.67a1.2 1.2 0 0 0-1.05-1.75h-1.8a7.47 7.47 0 0 0-1.31-.9l-.32-1.82A1.2 1.2 0 0 0 12 1.5c-.57 0-1.06.4-1.17.95l-.32 1.82a7.47 7.47 0 0 0-1.31.9H7.4a1.2 1.2 0 0 0-1.05 1.75l.87 1.67a7.47 7.47 0 0 0-.68 1.66l-1.74.58a1.2 1.2 0 0 0 0 2.28l1.74.58c.16.57.39 1.12.68 1.66l-.87 1.67A1.2 1.2 0 0 0 7.4 19.5h1.8c.4.35.84.66 1.31.9l.32 1.82c.11.55.6.95 1.17.95s1.06-.4 1.17-.95l.32-1.82c.47-.24.91-.55 1.31-.9h1.8c.87 0 1.45-.92 1.05-1.75l-.87-1.67c.29-.54.52-1.09.68-1.66l1.74-.58c.49-.16.84-.62.84-1.14Z"
                  />
                </svg>
                <span class="visually-hidden" data-settings-label>Show Controls</span>
              </button>
              <div
                id="flight-control-panel"
                class="control-panel is-collapsed"
                role="group"
                aria-label="Flight controls"
                aria-hidden="true"
              >
                <h2>Controls</h2>
                <button
                  type="button"
                  class="control-button"
                  data-control="toggle"
                  aria-pressed="true"
                >
                  Pause Flight
                </button>
                <div class="control-slider">
                  <label for="glide-speed">Throttle</label>
                  <input
                    id="glide-speed"
                    type="range"
                    min="0"
                    max="1"
                    step="0.01"
                    value="0.4"
                    aria-describedby="glide-speed-display"
                  />
                  <output id="glide-speed-display" data-display="glide-speed" for="glide-speed">
                    40%
                  </output>
                </div>
                <button type="button" class="control-button" data-control="environment">
                  Environment: Forest
                </button>
                <button type="button" class="control-button" data-control="reset">
                  Reset Camera
                </button>
                <div class="control-metrics" aria-live="polite" aria-atomic="true">
                  <div class="control-metrics__row">
                    <span class="control-metrics__label">Speed</span>
                    <span class="control-metrics__value" data-metric="speed">0.00u/s</span>
                  </div>
                  <div class="control-metrics__row">
                    <span class="control-metrics__label">Throttle</span>
                    <span class="control-metrics__value" data-metric="throttle">40%</span>
                  </div>
                  <div class="control-metrics__row">
                    <span class="control-metrics__label">FPS</span>
                    <span class="control-metrics__value" data-metric="fps">--</span>
                  </div>
                  <p class="control-metrics__note" data-metric="status">
                    Loading...
                  </p>
                </div>
              </div>
            </div>
            <button
              type="button"
              class="canvas-action-button fullscreen-toggle"
              data-control="fullscreen"
              aria-pressed="false"
              aria-label="Enter fullscreen"
            >
              <svg
                class="fullscreen-toggle__icon"
                viewBox="0 0 24 24"
                aria-hidden="true"
                focusable="false"
                data-icon="enter"
              >
                <path
                  d="M9 5H5v4M15 5h4v4M9 19H5v-4M15 19h4v-4"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
              </svg>
              <svg
                class="fullscreen-toggle__icon"
                viewBox="0 0 24 24"
                aria-hidden="true"
                focusable="false"
                data-icon="exit"
                hidden
              >
                <path
                  d="M9 7H7V5M17 7V5h-2M9 17v2H7M17 17h-2v2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
                <path
                  d="M15 9h4M15 15h4M5 9h4M5 15h4"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
              </svg>
              <span class="visually-hidden" data-fullscreen-label>Enter Fullscreen</span>
            </button>
            <button
              type="button"
              class="canvas-action-button environment-toggle"
              data-control="environment-toggle"
              aria-label="Cycle environment"
            >
              <svg
                class="environment-toggle__icon"
                viewBox="0 0 24 24"
                aria-hidden="true"
                focusable="false"
              >
                <path
                  d="M12 20.25a8.25 8.25 0 1 0 0-16.5 8.25 8.25 0 0 0 0 16.5Z"
                />
                <path d="M3.9 9.75h16.2m-16.2 4.5h16.2" />
                <path
                  d="M12 3.75c2.3 2.4 3.45 5.4 3.45 8.25S14.3 17.85 12 20.25m0-16.5c-2.3 2.4-3.45 5.4-3.45 8.25S9.7 17.85 12 20.25"
                />
              </svg>
              <span class="visually-hidden" data-environment-label>Environment: Forest</span>
            </button>
            <button
              type="button"
              class="canvas-action-button view-toggle"
              data-control="view-toggle"
              aria-label="Cycle camera view"
            >
              <svg
                class="view-toggle__icon"
                viewBox="0 0 24 24"
                aria-hidden="true"
                focusable="false"
              >
                <path
                  d="M2.25 12C4.2 7.7 7.8 5 12 5s7.8 2.7 9.75 7c-1.95 4.3-5.55 7-9.75 7s-7.8-2.7-9.75-7Zm9.75 4a4 4 0 1 0 0-8 4 4 0 0 0 0 8Zm0-1.5a2.5 2.5 0 1 1 0-5 2.5 2.5 0 0 1 0 5Z"
                />
              </svg>
              <span class="visually-hidden" data-view-label>Follow view</span>
            </button>
          </div>
        </div>
        <div class="touch-controls" aria-hidden="true">
          <div class="thumbstick" data-thumbstick="left">
            <div class="thumbstick__handle" data-thumbstick-handle></div>
          </div>
        </div>
      </div>
    </main>
    <noscript>Enable JavaScript to view the Birb Flight Lab experience.</noscript>

    <script type="module">
      // Global error handler for mobile debugging
      window.addEventListener("error", (event) => {
        const statusEl = document.querySelector('[data-metric="status"]');
        if (statusEl) {
          statusEl.textContent = `Error: ${event.message || "Unknown error"}`;
        }
        console.error("Global error:", event);
      });

      window.addEventListener("unhandledrejection", (event) => {
        const statusEl = document.querySelector('[data-metric="status"]');
        if (statusEl) {
          statusEl.textContent = `Load error: ${event.reason?.message || "Module failed to load"}`;
        }
        console.error("Unhandled rejection:", event);
      });

      let THREE, GLTFLoader, FreeFlightController, createCameraState, CAMERA_MODES, createFlightControls, createWorldShell, ENVIRONMENT_VARIANTS, getEnvironmentDefinition;

      try {
        THREE = await import("https://esm.sh/three@0.161.0");
        const flightModule = await import("./free-flight-controller.js");
        FreeFlightController = flightModule.FreeFlightController;
        const cameraModule = await import("./src/camera/camera-state.js");
        createCameraState = cameraModule.createCameraState;
        CAMERA_MODES = cameraModule.CAMERA_MODES;
        const controlsModule = await import("./src/controls/flight-controls.js");
        createFlightControls = controlsModule.createFlightControls;
        const worldModule = await import("./src/environment/world-shell.js");
        createWorldShell = worldModule.createWorldShell;
        ENVIRONMENT_VARIANTS = worldModule.ENVIRONMENT_VARIANTS;
        getEnvironmentDefinition = worldModule.getEnvironmentDefinition;
        const gltfLoaderModule = await import(
          "https://esm.sh/three@0.161.0/examples/jsm/loaders/GLTFLoader.js"
        );
        GLTFLoader = gltfLoaderModule.GLTFLoader;
      } catch (importError) {
        const statusEl = document.querySelector('[data-metric="status"]');
        if (statusEl) {
          statusEl.textContent = `Failed to load modules: ${importError.message}`;
        }
        console.error("Import error:", importError);
        throw importError;
      }

      // Update status after successful module load
      {
        const statusEl = document.querySelector('[data-metric="status"]');
        if (statusEl) {
          statusEl.textContent = "Modules loaded. Initializing renderer...";
        }
      }

      const canvasWrapper = document.querySelector(".canvas-wrapper");
      const canvasActions = document.querySelector("[data-draggable-panel]");
      const canvas = document.querySelector("#scene");

      const statusMetric = document.querySelector('[data-metric="status"]');

      const showFatalError = (message) => {
        if (statusMetric) {
          statusMetric.textContent = message;
        }
        throw new Error(message);
      };

      let renderer;
      try {
        renderer = new THREE.WebGLRenderer({
          canvas,
          antialias: true,
          alpha: true,
          powerPreference: "low-power",
          failIfMajorPerformanceCaveat: false,
        });
      } catch (error) {
        showFatalError("Unable to start WebGL — your browser may not support it.");
      }

      if (!renderer?.getContext()) {
        showFatalError("WebGL context unavailable. Please enable hardware acceleration.");
      }

      if (statusMetric) {
        statusMetric.textContent = "Renderer ready. Building scene...";
      }

      const contextState = { lost: false };

      const prefersCoarsePointer = window.matchMedia("(pointer: coarse)").matches;
      const DPR_CAP = prefersCoarsePointer ? 1.4 : 1.8;
      const resizeState = {
        width: 0,
        height: 0,
        pixelRatio: 1,
        dirty: true,
      };
      const actionPaletteState = {
        pointerId: null,
        offsetX: 0,
        offsetY: 0,
        width: 0,
        height: 0,
        hasCustomPosition: false,
        relativeX: 0,
        relativeY: 0,
      };

      function clamp(value, min, max) {
        if (!Number.isFinite(value)) {
          return 0;
        }
        return Math.min(Math.max(value, min), max);
      }

      function repositionActionPalette() {
        if (!canvasActions || !canvasWrapper || !actionPaletteState.hasCustomPosition)
          return;
        const wrapperRect = canvasWrapper.getBoundingClientRect();
        const width = canvasActions.offsetWidth;
        const height = canvasActions.offsetHeight;
        const maxX = Math.max(0, wrapperRect.width - width);
        const maxY = Math.max(0, wrapperRect.height - height);
        const left = clamp(actionPaletteState.relativeX * maxX, 0, maxX);
        const top = clamp(actionPaletteState.relativeY * maxY, 0, maxY);
        canvasActions.style.left = `${left}px`;
        canvasActions.style.top = `${top}px`;
        canvasActions.style.right = "auto";
        canvasActions.style.bottom = "auto";
      }

      if (canvasActions && canvasWrapper) {
        const dragListenerOptions = { passive: false };

        const handlePointerDown = (event) => {
          if (event.button !== 0 && event.pointerType !== "touch") return;
          const target = event.target;
          if (target && target.closest("button")) return;
          if (target && target.closest(".control-panel")) return;
          const actionsRect = canvasActions.getBoundingClientRect();
          actionPaletteState.pointerId = event.pointerId;
          actionPaletteState.offsetX = event.clientX - actionsRect.left;
          actionPaletteState.offsetY = event.clientY - actionsRect.top;
          actionPaletteState.width = actionsRect.width;
          actionPaletteState.height = actionsRect.height;
          canvasActions.classList.add("is-dragging");
          if (typeof canvasActions.setPointerCapture === "function") {
            try {
              canvasActions.setPointerCapture(event.pointerId);
            } catch (error) {
              // Ignore pointer capture errors in unsupported browsers.
            }
          }
          event.preventDefault();
        };

        const handlePointerMove = (event) => {
          if (actionPaletteState.pointerId !== event.pointerId) return;
          event.preventDefault();
          const wrapperRect = canvasWrapper.getBoundingClientRect();
          const width = canvasActions.offsetWidth;
          const height = canvasActions.offsetHeight;
          const maxX = Math.max(0, wrapperRect.width - width);
          const maxY = Math.max(0, wrapperRect.height - height);
          const rawLeft = event.clientX - actionPaletteState.offsetX - wrapperRect.left;
          const rawTop = event.clientY - actionPaletteState.offsetY - wrapperRect.top;
          const clampedLeft = clamp(rawLeft, 0, maxX);
          const clampedTop = clamp(rawTop, 0, maxY);
          canvasActions.style.left = `${clampedLeft}px`;
          canvasActions.style.top = `${clampedTop}px`;
          canvasActions.style.right = "auto";
          canvasActions.style.bottom = "auto";
          actionPaletteState.width = width;
          actionPaletteState.height = height;
          actionPaletteState.hasCustomPosition = true;
          actionPaletteState.relativeX = maxX > 0 ? clampedLeft / maxX : 0;
          actionPaletteState.relativeY = maxY > 0 ? clampedTop / maxY : 0;
        };

        const handlePointerEnd = (event) => {
          if (actionPaletteState.pointerId !== event.pointerId) return;
          if (
            typeof canvasActions.hasPointerCapture === "function" &&
            canvasActions.hasPointerCapture(event.pointerId) &&
            typeof canvasActions.releasePointerCapture === "function"
          ) {
            canvasActions.releasePointerCapture(event.pointerId);
          }
          canvasActions.classList.remove("is-dragging");
          actionPaletteState.pointerId = null;
          event.preventDefault();
        };

        canvasActions.addEventListener("pointerdown", handlePointerDown, dragListenerOptions);
        canvasActions.addEventListener("pointermove", handlePointerMove, dragListenerOptions);
        ["pointerup", "pointercancel", "lostpointercapture"].forEach((eventName) => {
          canvasActions.addEventListener(eventName, handlePointerEnd, dragListenerOptions);
        });

        window.addEventListener("resize", repositionActionPalette, { passive: true });
      }

      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.22;

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a1426);
      scene.fog = new THREE.Fog(0x0a1426, 10.5, 30);

      const ambient = new THREE.HemisphereLight(0xd4f1ff, 0x1a2f32, 0.92);
      ambient.groundColor.set(0x1a2f32);
      scene.add(ambient);

      const keyLight = new THREE.DirectionalLight(0xf3f0d2, 1.2);
      keyLight.position.set(7.5, 8.2, 5.2);
      scene.add(keyLight);

      const rimLight = new THREE.DirectionalLight(0x78b6ff, 0.48);
      rimLight.position.set(-6.2, 5.1, -5.4);
      scene.add(rimLight);

      const fillLight = new THREE.DirectionalLight(0x9fc8ff, 0.38);
      fillLight.position.set(1.2, 3.1, -6.2);
      scene.add(fillLight);

      const glowLight = new THREE.PointLight(0x63d0ff, 1.35, 12, 2.1);
      glowLight.position.set(0.3, 1.6, 0.8);
      scene.add(glowLight);

      const lightingRig = { ambient, keyLight, rimLight, fillLight, glowLight };

      const environmentButton = document.querySelector('[data-control="environment"]');
      const environmentToggleButton = document.querySelector(
        '[data-control="environment-toggle"]'
      );
      const environmentOrder = ENVIRONMENT_VARIANTS.map((variant) => variant.id);
      const defaultEnvironmentId = environmentOrder[0] ?? "forest";
      const defaultEnvironment =
        getEnvironmentDefinition(defaultEnvironmentId) ?? {
          id: defaultEnvironmentId,
          label: defaultEnvironmentId,
        };
      const environmentState = {
        order: environmentOrder,
        index: Math.max(0, environmentOrder.indexOf(defaultEnvironmentId)),
        id: defaultEnvironment.id,
        label: defaultEnvironment.label,
      };
      let environmentShell = null;
      let glideTrail = null;
      let flightControllerInitialized = false;

      function updateEnvironmentControls(config) {
        if (!config) return;
        const label = config.label ?? config.id;
        if (environmentButton) {
          environmentButton.textContent = `Environment: ${label}`;
          environmentButton.setAttribute(
            "aria-label",
            `Cycle environment (current: ${label})`
          );
          environmentButton.setAttribute("title", `Cycle environment • ${label}`);
        }
        if (environmentToggleButton) {
          const toggleLabel = environmentToggleButton.querySelector(
            '[data-environment-label]'
          );
          if (toggleLabel) {
            toggleLabel.textContent = `Environment: ${label}`;
          }
          environmentToggleButton.setAttribute(
            "aria-label",
            `Cycle environment (current: ${label})`
          );
          environmentToggleButton.setAttribute(
            "title",
            `Cycle environment • ${label}`
          );
        }
      }

      function applyLightingPreset(config) {
        if (!config || !config.lighting) return;
        const { ambient, key, rim, fill, glow } = config.lighting;
        if (ambient && lightingRig.ambient) {
          if (ambient.sky !== undefined) {
            lightingRig.ambient.color.setHex(ambient.sky);
          }
          if (ambient.ground !== undefined) {
            lightingRig.ambient.groundColor.setHex(ambient.ground);
          }
          if (ambient.intensity !== undefined) {
            lightingRig.ambient.intensity = ambient.intensity;
          }
        }
        if (key && lightingRig.keyLight) {
          if (key.color !== undefined) {
            lightingRig.keyLight.color.setHex(key.color);
          }
          if (key.intensity !== undefined) {
            lightingRig.keyLight.intensity = key.intensity;
          }
          if (Array.isArray(key.position)) {
            lightingRig.keyLight.position.set(...key.position);
          }
        }
        if (rim && lightingRig.rimLight) {
          if (rim.color !== undefined) {
            lightingRig.rimLight.color.setHex(rim.color);
          }
          if (rim.intensity !== undefined) {
            lightingRig.rimLight.intensity = rim.intensity;
          }
          if (Array.isArray(rim.position)) {
            lightingRig.rimLight.position.set(...rim.position);
          }
        }
        if (fill && lightingRig.fillLight) {
          if (fill.color !== undefined) {
            lightingRig.fillLight.color.setHex(fill.color);
          }
          if (fill.intensity !== undefined) {
            lightingRig.fillLight.intensity = fill.intensity;
          }
          if (Array.isArray(fill.position)) {
            lightingRig.fillLight.position.set(...fill.position);
          }
        }
        if (glow && lightingRig.glowLight) {
          if (glow.color !== undefined) {
            lightingRig.glowLight.color.setHex(glow.color);
          }
          if (glow.intensity !== undefined) {
            lightingRig.glowLight.intensity = glow.intensity;
          }
          if (glow.distance !== undefined) {
            lightingRig.glowLight.distance = glow.distance;
          }
          if (glow.decay !== undefined) {
            lightingRig.glowLight.decay = glow.decay;
          }
          if (Array.isArray(glow.position)) {
            lightingRig.glowLight.position.set(...glow.position);
          }
        }
      }

      function setEnvironment(variantId) {
        const definition = getEnvironmentDefinition(variantId);
        if (!definition) return;

        if (environmentShell) {
          try {
            environmentShell.dispose();
          } catch (disposeError) {
            console.warn("Environment dispose error:", disposeError);
          }
        }

        try {
          environmentShell = createWorldShell(scene, {
            three: THREE,
            variant: definition.id,
          });
          glideTrail = environmentShell.glideTrail;
        } catch (envError) {
          console.warn("Environment creation failed:", envError);
          environmentShell = null;
          glideTrail = null;
        }
        environmentState.id = definition.id;
        environmentState.label = definition.label;
        const resolvedIndex = environmentState.order.indexOf(definition.id);
        environmentState.index = resolvedIndex >= 0 ? resolvedIndex : 0;
        updateEnvironmentControls(definition);
        applyLightingPreset(definition);
        if (flightControllerInitialized) {
          updateControlMetrics();
        }
      }

      function cycleEnvironment(step = 1) {
        const { order } = environmentState;
        if (!order || order.length === 0) {
          return;
        }

        const total = order.length;
        const nextIndex = (environmentState.index + step + total) % total;
        const nextId = order[nextIndex];
        setEnvironment(nextId);
      }

      try {
        setEnvironment(defaultEnvironment.id);
      } catch (initEnvError) {
        console.warn("Initial environment setup failed:", initEnvError);
      }

      if (environmentButton) {
        environmentButton.addEventListener("click", () => {
          cycleEnvironment(1);
        });
      }

      if (environmentToggleButton) {
        environmentToggleButton.addEventListener("click", () => {
          cycleEnvironment(1);
        });
      }


      const birbAnchor = new THREE.Group();
      scene.add(birbAnchor);

      // Align the sculpted bird (modeled along the +X axis) with the
      // controller's forward vector (-Z) by rotating 90° anticlockwise so the
      // beak points in the direction of travel.
      const modelOrientationOffset = new THREE.Quaternion().setFromEuler(
        new THREE.Euler(0, Math.PI / 2, 0)
      );

      const positionBirbModel = (model) => {
        if (!model) return;

        model.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = false;
            child.receiveShadow = false;
          }
        });

        model.updateMatrixWorld(true);
        const birbBounds = new THREE.Box3().setFromObject(model);
        const birbCenter = new THREE.Vector3();
        birbBounds.getCenter(birbCenter);
        // Re-center the bird so yaw/roll rotations pivot around its body instead
        // of an offset point in space.
        model.position.sub(birbCenter);

        birbAnchor.clear();
        birbAnchor.add(model);
        birbAnchor.scale.setScalar(0.52);
      };

      const createProceduralBirb = () => {
        const birbModel = new THREE.Group();

        const plumageMaterial = new THREE.MeshStandardMaterial({
          color: 0x6f9df2,
          metalness: 0.18,
          roughness: 0.46,
          emissive: 0x162a49,
          emissiveIntensity: 0.18,
        });

        const bodyGeometry = new THREE.SphereGeometry(0.62, 40, 28);
        const body = new THREE.Mesh(bodyGeometry, plumageMaterial);
        body.scale.set(1.46, 1.08, 1.04);
        body.position.set(-0.02, -0.02, 0);
        birbModel.add(body);

        const bellyGeometry = new THREE.SphereGeometry(0.46, 36, 24);
        const bellyMaterial = new THREE.MeshStandardMaterial({
          color: 0xf3ede0,
          metalness: 0.08,
          roughness: 0.58,
          emissive: 0x1b1a19,
          emissiveIntensity: 0.06,
        });
        const belly = new THREE.Mesh(bellyGeometry, bellyMaterial);
        belly.scale.set(1.08, 0.88, 0.86);
        belly.position.set(0.28, -0.16, 0);
        birbModel.add(belly);

        const headGeometry = new THREE.SphereGeometry(0.32, 36, 24);
        const headMaterial = plumageMaterial.clone();
        headMaterial.color = new THREE.Color(0x83b8ff);
        headMaterial.roughness = 0.4;
        headMaterial.emissiveIntensity = 0.14;
        const head = new THREE.Mesh(headGeometry, headMaterial);
        head.position.set(0.82, 0.26, 0);
        birbModel.add(head);

        const neckGeometry = new THREE.SphereGeometry(0.28, 32, 24, 0, Math.PI * 2, 0, Math.PI / 1.35);
        const neck = new THREE.Mesh(neckGeometry, bellyMaterial.clone());
        neck.scale.set(0.98, 0.82, 0.88);
        neck.rotation.z = Math.PI / 2;
        neck.position.set(0.46, 0.06, 0);
        birbModel.add(neck);

        const beakMaterial = new THREE.MeshStandardMaterial({
          color: 0xf3ad58,
          metalness: 0.18,
          roughness: 0.34,
          emissive: 0x3b1f08,
          emissiveIntensity: 0.24,
        });

        const upperBeakGeometry = new THREE.ConeGeometry(0.11, 0.4, 32);
        const upperBeak = new THREE.Mesh(upperBeakGeometry, beakMaterial);
        upperBeak.scale.set(1.05, 0.82, 1.18);
        upperBeak.rotation.set(0.14, 0, -Math.PI / 2.18);
        upperBeak.position.set(1.18, 0.2, 0.02);
        birbModel.add(upperBeak);

        const lowerBeakMaterial = beakMaterial.clone();
        lowerBeakMaterial.color = new THREE.Color(0xf09b3c);
        lowerBeakMaterial.roughness = 0.42;
        const lowerBeakGeometry = new THREE.ConeGeometry(0.095, 0.3, 30);
        const lowerBeak = new THREE.Mesh(lowerBeakGeometry, lowerBeakMaterial);
        lowerBeak.scale.set(1.02, 0.86, 1.08);
        lowerBeak.rotation.set(0.14, 0, -Math.PI / 1.95);
        lowerBeak.position.set(1.06, 0.12, -0.01);
        birbModel.add(lowerBeak);

        const eyeGeometry = new THREE.SphereGeometry(0.04, 20, 18);
        const eyeMaterial = new THREE.MeshStandardMaterial({
          color: 0x0c0f1a,
          metalness: 0.6,
          roughness: 0.18,
          emissive: 0x070a0f,
          emissiveIntensity: 0.35,
        });
        const eyeHighlightMaterial = new THREE.MeshStandardMaterial({
          color: 0xf7f6f4,
          metalness: 0.2,
          roughness: 0.18,
          emissive: 0x262626,
          emissiveIntensity: 0.2,
        });
        const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        leftEye.position.set(0.9, 0.26, 0.12);
        const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial.clone());
        rightEye.position.set(0.9, 0.26, -0.12);
        birbModel.add(leftEye);
        birbModel.add(rightEye);

        const eyeHighlightGeometry = new THREE.SphereGeometry(0.018, 16, 14);
        const leftHighlight = new THREE.Mesh(eyeHighlightGeometry, eyeHighlightMaterial);
        leftHighlight.position.set(0.93, 0.3, 0.12);
        const rightHighlight = new THREE.Mesh(eyeHighlightGeometry, eyeHighlightMaterial.clone());
        rightHighlight.position.set(0.93, 0.3, -0.12);
        birbModel.add(leftHighlight);
        birbModel.add(rightHighlight);

        const crestMaterial = plumageMaterial.clone();
        crestMaterial.color = new THREE.Color(0x91c7ff);
        crestMaterial.roughness = 0.38;
        crestMaterial.metalness = 0.12;
        crestMaterial.emissive = new THREE.Color(0x1d334f);
        crestMaterial.emissiveIntensity = 0.18;
        const crestGeometry = new THREE.ConeGeometry(0.1, 0.42, 18);
        crestGeometry.translate(0, 0.21, 0);
        const crest = new THREE.Mesh(crestGeometry, crestMaterial);
        crest.rotation.set(0, 0, -Math.PI / 2.1);
        crest.position.set(0.64, 0.34, 0);
        crest.scale.set(0.84, 1, 0.84);
        birbModel.add(crest);

        const wingMaterial = plumageMaterial.clone();
        wingMaterial.roughness = 0.35;
        wingMaterial.metalness = 0.22;
        wingMaterial.emissive = new THREE.Color(0x1a2d4c);
        wingMaterial.emissiveIntensity = 0.22;
        const wingGeometry = new THREE.CapsuleGeometry(0.26, 0.8, 16, 24);
        wingGeometry.rotateZ(Math.PI / 2);
        wingGeometry.translate(0, 0, 0);

        const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
        leftWing.position.set(-0.18, 0.1, 0.64);
        leftWing.rotation.set(Math.PI / 2.2, -Math.PI / 4, Math.PI / 2.6);
        leftWing.scale.set(1.06, 1.06, 1.1);
        birbModel.add(leftWing);

        const rightWing = new THREE.Mesh(wingGeometry, wingMaterial.clone());
        rightWing.position.set(-0.18, 0.1, -0.64);
        rightWing.rotation.set(Math.PI / 2.2, Math.PI / 4, Math.PI / 2.6);
        rightWing.scale.set(1.06, 1.06, 1.1);
        birbModel.add(rightWing);

        const tailMaterial = plumageMaterial.clone();
        tailMaterial.color = new THREE.Color(0x5f8fd6);
        tailMaterial.roughness = 0.42;
        tailMaterial.emissive = new THREE.Color(0x13243d);
        tailMaterial.emissiveIntensity = 0.2;
        const tailFeatherMaterial = plumageMaterial.clone();
        tailFeatherMaterial.color = new THREE.Color(0x6ea6f7);
        tailFeatherMaterial.roughness = 0.4;
        tailFeatherMaterial.emissive = new THREE.Color(0x162d4f);
        tailFeatherMaterial.emissiveIntensity = 0.18;

        const tailBaseGeometry = new THREE.ConeGeometry(0.32, 0.72, 20);
        tailBaseGeometry.rotateZ(Math.PI / 2);
        const tailBase = new THREE.Mesh(tailBaseGeometry, tailMaterial);
        tailBase.position.set(-0.38, -0.16, 0);
        tailBase.rotation.set(0.12, 0, Math.PI / 20);
        tailBase.scale.set(1.08, 1, 0.92);

        const tailFanGeometry = new THREE.ConeGeometry(0.34, 0.94, 18);
        tailFanGeometry.rotateZ(Math.PI / 2);
        const tailFan = new THREE.Mesh(tailFanGeometry, tailFeatherMaterial);
        tailFan.position.set(-0.8, -0.16, 0);
        tailFan.rotation.set(0.22, 0, Math.PI / 10);
        tailFan.scale.set(1.2, 1.08, 1);

        const tailGroup = new THREE.Group();
        tailGroup.add(tailBase);
        tailGroup.add(tailFan);
        birbModel.add(tailGroup);

        const legMaterial = new THREE.MeshStandardMaterial({
          color: 0xd8995f,
          metalness: 0.2,
          roughness: 0.36,
          emissive: 0x201204,
          emissiveIntensity: 0.24,
        });

        const legGeometry = new THREE.CylinderGeometry(0.04, 0.055, 0.42, 14);
        const ankleGeometry = new THREE.SphereGeometry(0.07, 16, 12);
        const footPadGeometry = new THREE.SphereGeometry(0.14, 22, 18);
        const toeGeometry = new THREE.CapsuleGeometry(0.03, 0.24, 8, 16);
        const backToeGeometry = new THREE.CapsuleGeometry(0.026, 0.16, 6, 14);
        const clawGeometry = new THREE.ConeGeometry(0.02, 0.08, 14);

        const toeMaterial = new THREE.MeshStandardMaterial({
          color: 0xe1ab73,
          metalness: 0.22,
          roughness: 0.4,
          emissive: 0x29180a,
          emissiveIntensity: 0.26,
        });
        const clawMaterial = new THREE.MeshStandardMaterial({
          color: 0x2d2a28,
          metalness: 0.35,
          roughness: 0.3,
          emissive: 0x0d0c0b,
          emissiveIntensity: 0.24,
        });

        const createFoot = (side = 1) => {
          const footGroup = new THREE.Group();

          const leg = new THREE.Mesh(legGeometry, legMaterial);
          leg.rotation.set(0.12, side * -0.08, Math.PI / 2.24);
          leg.position.set(0.02, -0.2, side * -0.02);
          footGroup.add(leg);

          const ankle = new THREE.Mesh(ankleGeometry, legMaterial.clone());
          ankle.scale.set(1.15, 0.82, 1.15);
          ankle.position.set(0.18, -0.36, side * -0.02);
          footGroup.add(ankle);

          const pad = new THREE.Mesh(footPadGeometry, legMaterial.clone());
          pad.scale.set(1.8, 0.42, 1.36);
          pad.position.set(0.3, -0.42, side * -0.02);
          footGroup.add(pad);

          const toeLayout = [
            { angle: 0.34, z: 0.16, length: 1.08 },
            { angle: 0.08, z: 0, length: 1.18 },
            { angle: -0.28, z: -0.16, length: 1 },
          ];

          toeLayout.forEach(({ angle, z, length }) => {
            const toeGroup = new THREE.Group();
            toeGroup.rotation.y = angle * side;
            toeGroup.position.set(0.38, -0.46, side * (z - 0.02));

            const toe = new THREE.Mesh(toeGeometry, toeMaterial);
            toe.scale.set(1, length, 1);
            toe.rotation.set(Math.PI / 7, 0, Math.PI / 2);
            toeGroup.add(toe);

            const claw = new THREE.Mesh(clawGeometry, clawMaterial);
            claw.rotation.set(Math.PI / 2.6, 0, -Math.PI / 2);
            claw.position.set(0.18 * length + 0.04, -0.02, 0);
            toeGroup.add(claw);

            footGroup.add(toeGroup);
          });

          const backToe = new THREE.Mesh(backToeGeometry, toeMaterial);
          backToe.rotation.set(-Math.PI / 2.1, 0, Math.PI / 2);
          backToe.position.set(0.14, -0.42, side * -0.12);
          footGroup.add(backToe);

          const backClaw = new THREE.Mesh(clawGeometry, clawMaterial.clone());
          backClaw.scale.set(0.9, 0.82, 0.9);
          backClaw.rotation.set(-Math.PI / 2.4, 0, -Math.PI / 2);
          backClaw.position.set(0.02, -0.4, side * -0.12);
          footGroup.add(backClaw);

          return footGroup;
        };

        const leftFoot = createFoot(1);
        leftFoot.position.set(0.26, -0.54, 0.34);
        leftFoot.rotation.set(0.02, 0.08, -0.04);
        birbModel.add(leftFoot);

        const rightFoot = createFoot(-1);
        rightFoot.position.set(0.26, -0.54, -0.34);
        rightFoot.rotation.set(0.02, -0.08, 0.04);
        birbModel.add(rightFoot);

        return birbModel;
      };

      positionBirbModel(createProceduralBirb());

      if (GLTFLoader) {
        const gltfLoader = new GLTFLoader();
        gltfLoader.load(
          "./birb.glb",
          (gltf) => {
            const model = gltf.scene || gltf.scenes?.[0];
            if (!model) return;
            positionBirbModel(model);
          },
          undefined,
          (error) => {
            console.warn("Failed to load birb GLB; using procedural model", error);
          }
        );
      }

      const motionQuery = window.matchMedia("(prefers-reduced-motion: reduce)");
      const motionState = {
        animate: !motionQuery.matches,
        elapsed: 0,
      };

      const fpsState = {
        lastSampleTime: null,
        frames: 0,
        value: 0,
      };

      let previousTime = null;

      const toggleButton = document.querySelector('[data-control="toggle"]');
      const resetButton = document.querySelector('[data-control="reset"]');
      const controlPanel = document.querySelector("#flight-control-panel");
      const panelToggleButton = document.querySelector('[data-control="panel-toggle"]');
      const fullscreenToggleButton = document.querySelector('[data-control="fullscreen"]');
      const viewToggleButton = document.querySelector('[data-control="view-toggle"]');
      const viewToggleLabel = viewToggleButton
        ? viewToggleButton.querySelector('[data-view-label]')
        : null;
      const glideSpeedInput = document.querySelector("#glide-speed");
      const glideSpeedDisplay = document.querySelector('[data-display="glide-speed"]');
      const speedMetric = document.querySelector('[data-metric="speed"]');
      const throttleMetric = document.querySelector('[data-metric="throttle"]');
      const fpsMetric = document.querySelector('[data-metric="fps"]');
      const panelToggleLabel = panelToggleButton
        ? panelToggleButton.querySelector('[data-settings-label]')
        : null;
      const fullscreenToggleLabel = fullscreenToggleButton
        ? fullscreenToggleButton.querySelector('[data-fullscreen-label]')
        : null;
      const fullscreenEnterIcon = fullscreenToggleButton
        ? fullscreenToggleButton.querySelector('[data-icon="enter"]')
        : null;
      const fullscreenExitIcon = fullscreenToggleButton
        ? fullscreenToggleButton.querySelector('[data-icon="exit"]')
        : null;

      const initialThrottle = clampThrottle(Number.parseFloat(glideSpeedInput?.value ?? ""));

      const controlState = {
        manuallyPaused: false,
        systemPaused: motionQuery.matches,
      };

      const fullscreenState = {
        fallbackActive: false,
      };

      function updateFpsReadout(time) {
        if (!fpsMetric) return;

        if (fpsState.lastSampleTime === null) {
          fpsState.lastSampleTime = time;
          fpsState.frames = 0;
          return;
        }

        fpsState.frames += 1;
        const elapsed = time - fpsState.lastSampleTime;
        if (elapsed < 250) {
          return;
        }

        const fps = (fpsState.frames / elapsed) * 1000;
        fpsState.value = fps;
        fpsState.frames = 0;
        fpsState.lastSampleTime = time;
        const formatted = Math.max(0, Math.round(fps)).toString().padStart(2, "0");
        fpsMetric.textContent = formatted;
      }

      function getCameraModeLabel(mode) {
        switch (mode) {
          case CAMERA_MODES.SEQUENCE:
            return "Sequence view";
          case CAMERA_MODES.FPV:
            return "FPV view";
          case CAMERA_MODES.FIXED:
            return "Fixed view";
          case CAMERA_MODES.FOLLOW:
          default:
            return "Follow view";
        }
      }

      function updateViewToggleUi(mode = cameraState?.getMode?.()) {
        if (!viewToggleButton) return;
        const modeLabel = getCameraModeLabel(mode);
        if (viewToggleLabel) {
          viewToggleLabel.textContent = modeLabel;
        }
        viewToggleButton.setAttribute(
          "aria-label",
          `Cycle camera view (current: ${modeLabel})`
        );
        viewToggleButton.setAttribute("title", `Cycle camera view • ${modeLabel}`);
      }

      function updateControlMetrics(speed = flightController.getSpeed()) {
        const throttlePercent = Math.round(flightController.getEffectiveThrottle() * 100);
        const safeSpeed = Number.isFinite(speed) ? speed : 0;
        if (speedMetric) {
          speedMetric.textContent = `${safeSpeed.toFixed(2)}u/s`;
        }
        if (throttleMetric) {
          throttleMetric.textContent = `${throttlePercent}%`;
        }
        if (statusMetric) {
          if (contextState.lost) {
            statusMetric.textContent = "Rendering paused while recovering graphics context...";
          } else if (controlState.systemPaused) {
            statusMetric.textContent = "Motion paused via system preference";
          } else if (!motionState.animate) {
            statusMetric.textContent = "Flight paused";
          } else if (flightController.isSprinting) {
            statusMetric.textContent = "Speed boost engaged";
          } else if (safeSpeed < 0.25) {
            statusMetric.textContent = "Hovering in place. Push the left stick forward to cruise.";
          } else {
            const mode = cameraState?.getMode?.();
            const modeLabel = getCameraModeLabel(mode);
            const instruction = viewToggleButton
              ? "tap the eye icon or press V"
              : "press V to change";
            const environmentMessage = environmentState.label
              ? `the ${environmentState.label} environment`
              : "this environment";
            statusMetric.textContent =
              `Exploring ${environmentMessage}. (${modeLabel} — ${instruction})`;
          }
        }
      }

      function updateToggleButton() {
        if (controlState.systemPaused) {
          toggleButton.disabled = true;
          toggleButton.setAttribute("aria-pressed", "false");
          toggleButton.textContent = "Motion Disabled";
        } else {
          toggleButton.disabled = false;
          toggleButton.textContent = motionState.animate ? "Pause Flight" : "Resume Flight";
          toggleButton.setAttribute("aria-pressed", motionState.animate ? "true" : "false");
        }
      }

      function refreshAnimationState() {
        motionState.animate = !(controlState.manuallyPaused || controlState.systemPaused);
        if (!motionState.animate) {
          previousTime = null;
        }
        updateToggleButton();
        updateControlMetrics();
      }

      function updatePanelToggle() {
        if (!panelToggleButton || !controlPanel) return;
        const isCollapsed = controlPanel.classList.contains("is-collapsed");
        if (panelToggleLabel) {
          panelToggleLabel.textContent = isCollapsed ? "Show Controls" : "Hide Controls";
        }
        panelToggleButton.setAttribute("aria-pressed", isCollapsed ? "false" : "true");
        panelToggleButton.setAttribute("aria-expanded", isCollapsed ? "false" : "true");
        panelToggleButton.setAttribute(
          "aria-label",
          isCollapsed ? "Show flight controls" : "Hide flight controls"
        );
        controlPanel.setAttribute("aria-hidden", isCollapsed ? "true" : "false");
      }

      function setControlPanelCollapsed(collapsed) {
        if (!controlPanel) return;
        controlPanel.classList.toggle("is-collapsed", Boolean(collapsed));
        updatePanelToggle();
      }

      function toggleControlPanel() {
        if (!controlPanel) return;
        const shouldCollapse = !controlPanel.classList.contains("is-collapsed");
        setControlPanelCollapsed(shouldCollapse);
      }

      if (panelToggleButton) {
        panelToggleButton.addEventListener("click", () => {
          toggleControlPanel();
        });
      }

      updatePanelToggle();

      function getFullscreenElement() {
        return (
          document.fullscreenElement ||
          document.webkitFullscreenElement ||
          document.mozFullScreenElement ||
          document.msFullscreenElement ||
          null
        );
      }

      function callFullscreenMethod(target, methodNames) {
        if (!target) return null;
        for (const methodName of methodNames) {
          const method = target[methodName];
          if (typeof method === "function") {
            return method.call(target);
          }
        }
        return null;
      }

      function ensurePromise(result) {
        if (result && typeof result.then === "function") {
          return result;
        }
        return Promise.resolve();
      }

      function requestFullscreen(element) {
        const targets = [element, document.documentElement, document.body].filter(Boolean);
        let lastError = null;

        const attemptAtIndex = (index = 0) => {
          if (index >= targets.length) {
            return Promise.reject(lastError ?? new Error("Fullscreen not supported"));
          }

          const target = targets[index];
          const result = callFullscreenMethod(target, [
            "requestFullscreen",
            "webkitRequestFullscreen",
            "mozRequestFullScreen",
            "msRequestFullscreen",
          ]);

          if (result === null) {
            return attemptAtIndex(index + 1);
          }

          return ensurePromise(result)
            .then(() => target)
            .catch((error) => {
              lastError = error;
              return attemptAtIndex(index + 1);
            });
        };

        return attemptAtIndex();
      }

      function exitFullscreen() {
        const result = callFullscreenMethod(document, [
          "exitFullscreen",
          "webkitExitFullscreen",
          "mozCancelFullScreen",
          "msExitFullscreen",
        ]);

        if (!result) {
          return Promise.resolve();
        }

        return ensurePromise(result);
      }

      function isFullscreenActive() {
        if (fullscreenState.fallbackActive) {
          return true;
        }
        const fullscreenElement = getFullscreenElement();
        if (!fullscreenElement) {
          return false;
        }
        return (
          fullscreenElement === canvasWrapper ||
          fullscreenElement === document.documentElement ||
          fullscreenElement === document.body
        );
      }

      function syncFullscreenUi() {
        if (!fullscreenToggleButton) return;
        const fullscreenElement = getFullscreenElement();
        const isDocumentFullscreen =
          fullscreenElement === document.documentElement || fullscreenElement === document.body;
        const isFallbackFullscreen = fullscreenState.fallbackActive && !fullscreenElement;
        const isFullscreen =
          fullscreenElement === canvasWrapper || isDocumentFullscreen || isFallbackFullscreen;
        const labelText = isFullscreen ? "Exit Fullscreen" : "Enter Fullscreen";
        fullscreenToggleButton.setAttribute("aria-pressed", isFullscreen ? "true" : "false");
        fullscreenToggleButton.setAttribute("aria-label", labelText);
        if (fullscreenToggleLabel) {
          fullscreenToggleLabel.textContent = labelText;
        }
        if (fullscreenEnterIcon && fullscreenExitIcon) {
          fullscreenEnterIcon.toggleAttribute("hidden", isFullscreen);
          fullscreenExitIcon.toggleAttribute("hidden", !isFullscreen);
        }
        if (canvasWrapper) {
          const shouldApplyFallback = isDocumentFullscreen || isFallbackFullscreen;
          canvasWrapper.classList.toggle("is-fullscreen-fallback", shouldApplyFallback);
        }
        if (document.body) {
          const shouldApplyFallback = isDocumentFullscreen || isFallbackFullscreen;
          document.body.classList.toggle("is-fullscreen-fallback", shouldApplyFallback);
        }
      }

      function enterFullscreenFallback() {
        if (fullscreenState.fallbackActive) return;
        fullscreenState.fallbackActive = true;
        syncFullscreenUi();
      }

      function exitFullscreenFallback() {
        if (!fullscreenState.fallbackActive) {
          syncFullscreenUi();
          return;
        }
        fullscreenState.fallbackActive = false;
        syncFullscreenUi();
      }

      function toggleFullscreen() {
        if (!canvasWrapper) return;

        if (isFullscreenActive()) {
          const exitResult = exitFullscreen();
          if (exitResult && typeof exitResult.then === "function") {
            exitResult
              .catch(() => {})
              .finally(() => {
                exitFullscreenFallback();
              });
          } else {
            exitFullscreenFallback();
          }
          return;
        }

        requestFullscreen(canvasWrapper)
          .then(() => {
            fullscreenState.fallbackActive = false;
            syncFullscreenUi();
          })
          .catch(() => {
            enterFullscreenFallback();
          });
      }

      const fullscreenChangeEvents = [
        "fullscreenchange",
        "webkitfullscreenchange",
        "mozfullscreenchange",
        "MSFullscreenChange",
      ];
      fullscreenChangeEvents.forEach((eventName) => {
        document.addEventListener(eventName, () => {
          fullscreenState.fallbackActive = false;
          syncFullscreenUi();
        });
      });

      const fullscreenErrorEvents = [
        "fullscreenerror",
        "webkitfullscreenerror",
        "mozfullscreenerror",
        "MSFullscreenError",
      ];
      fullscreenErrorEvents.forEach((eventName) => {
        document.addEventListener(eventName, () => {
          if (!isFullscreenActive()) {
            enterFullscreenFallback();
          }
        });
      });

      if (fullscreenToggleButton) {
        fullscreenToggleButton.addEventListener("click", () => {
          toggleFullscreen();
        });
      }

      syncFullscreenUi();

      function clampThrottle(value, fallback = 0.6) {
        if (!Number.isFinite(value)) {
          return fallback;
        }
        return Math.min(Math.max(value, 0), 1);
      }

      function updateGlideSpeedDisplay(value) {
        if (!glideSpeedDisplay) return;
        const throttlePercent = Math.round(value * 100);
        glideSpeedDisplay.textContent = `${throttlePercent}%`;
      }

      motionQuery.addEventListener("change", (event) => {
        controlState.systemPaused = event.matches;
        refreshAnimationState();
      });

      let cameraState = null;
      const CAMERA_MODE_SEQUENCE = [
        CAMERA_MODES.FOLLOW,
        CAMERA_MODES.FPV,
      ];
      let cameraModeIndex = 0;

      function invalidateRendererSize() {
        resizeState.dirty = true;
      }

      function updateRendererSize(force = false) {
        if (!resizeState.dirty && !force) {
          return;
        }

        const clientWidth = canvas.clientWidth || window.innerWidth;
        const clientHeight = canvas.clientHeight || window.innerHeight;

        if (!clientWidth || !clientHeight) return;

        const nextWidth = Math.floor(clientWidth);
        const nextHeight = Math.floor(clientHeight);
        const pixelRatio = Math.min(window.devicePixelRatio || 1, DPR_CAP);

        if (
          !force &&
          resizeState.width === nextWidth &&
          resizeState.height === nextHeight &&
          resizeState.pixelRatio === pixelRatio
        ) {
          resizeState.dirty = false;
          return;
        }

        resizeState.width = nextWidth;
        resizeState.height = nextHeight;
        resizeState.pixelRatio = pixelRatio;
        resizeState.dirty = false;

        renderer.setPixelRatio(pixelRatio);
        renderer.setSize(nextWidth, nextHeight, false);
        if (cameraState) {
          const camera = cameraState.camera;
          camera.aspect = nextWidth / nextHeight;
          camera.updateProjectionMatrix();
        }
      }

      const resizeObserver =
        typeof ResizeObserver !== "undefined"
          ? new ResizeObserver(() => {
              invalidateRendererSize();
              updateRendererSize();
            })
          : null;
      if (resizeObserver) {
        resizeObserver.observe(canvas);
      }
      window.addEventListener(
        "orientationchange",
        () => {
          invalidateRendererSize();
          updateRendererSize(true);
        },
        {
          passive: true,
        }
      );
      window.addEventListener(
        "resize",
        () => {
          invalidateRendererSize();
          updateRendererSize();
        },
        { passive: true }
      );

      const flightController = new FreeFlightController(THREE, {
        position: new THREE.Vector3(1.1, 0.9, 0),
        throttle: initialThrottle,
      });
      flightController.setThrottle(initialThrottle);
      flightControllerInitialized = true;
      updateControlMetrics();

      cameraState = createCameraState({
        three: THREE,
        scene,
        flightController,
      });

      const syncAvatarVisibility = (mode) => {
        if (!birbAnchor) return;
        birbAnchor.visible = mode !== CAMERA_MODES.FPV;
      };

      const setCameraMode = (mode) => {
        if (!cameraState) return;
        cameraState.setMode(mode);
        const index = CAMERA_MODE_SEQUENCE.indexOf(mode);
        if (index !== -1) {
          cameraModeIndex = index;
        }
        syncAvatarVisibility(mode);
        updateControlMetrics();
        updateViewToggleUi(mode);
      };

      const cycleCameraMode = () => {
        const nextIndex = (cameraModeIndex + 1) % CAMERA_MODE_SEQUENCE.length;
        setCameraMode(CAMERA_MODE_SEQUENCE[nextIndex]);
      };

      setCameraMode(CAMERA_MODE_SEQUENCE[cameraModeIndex]);

      const blendedQuaternion = new THREE.Quaternion();

      const flightControls = createFlightControls({
        canvas,
        flightController,
        leftThumbstickElement: document.querySelector('[data-thumbstick="left"]'),
        rightThumbstickElement: document.querySelector('[data-thumbstick="right"]'),
        liftButtonElements: Array.from(document.querySelectorAll('[data-lift-button]')),
        getCameraMode: () => cameraState?.getMode?.(),
        followMode: CAMERA_MODES.FOLLOW,
        onSprintChange: () => updateControlMetrics(),
        onThrustChange: () => updateControlMetrics(),
      });

      const applyThrottleFromInput = () => {
        if (!glideSpeedInput) return;
        const value = clampThrottle(Number.parseFloat(glideSpeedInput.value));
        flightController.setThrottle(value);
        updateGlideSpeedDisplay(value);
        updateControlMetrics();
      };

      if (glideSpeedInput) {
        updateGlideSpeedDisplay(initialThrottle);
        glideSpeedInput.value = `${initialThrottle}`;
        glideSpeedInput.addEventListener("input", applyThrottleFromInput);
        glideSpeedInput.addEventListener("change", applyThrottleFromInput);
      } else {
        updateGlideSpeedDisplay(initialThrottle);
      }

      if (resetButton) {
        resetButton.addEventListener("click", () => {
          flightController.reset();
          cameraState.reset();
          const currentMode = cameraState.getMode();
          const currentIndex = CAMERA_MODE_SEQUENCE.indexOf(currentMode);
          cameraModeIndex = currentIndex === -1 ? 0 : currentIndex;
          updateViewToggleUi(currentMode);
          flightControls.reset({ releasePointerLock: true });
          updateControlMetrics();
        });
      }

      if (viewToggleButton) {
        viewToggleButton.addEventListener("click", () => {
          cycleCameraMode();
        });
      }

      document.addEventListener("keydown", (event) => {
        const { code } = event;
        if (
          event.target &&
          (event.target.isContentEditable || /^(INPUT|TEXTAREA|SELECT)$/i.test(event.target.tagName))
        ) {
          return;
        }
        if (code === "KeyV" && !event.repeat) {
          cycleCameraMode();
          event.preventDefault();
        }
      });

      window.addEventListener("blur", () => {
        flightControls.reset({ releasePointerLock: true });
      });

      const renderFrame = (time = 0) => {
        if (contextState.lost) {
          return;
        }
        let delta = 0;
        if (motionState.animate) {
          if (previousTime === null) {
            previousTime = time;
          }
          delta = (time - previousTime) * 0.001;
          motionState.elapsed += delta;
          previousTime = time;
        } else {
          previousTime = null;
        }

        const lookDeltaTime = Math.min(delta > 0 ? delta : 1 / 60, 0.05);
        flightControls.applyAnalogLook(lookDeltaTime);

        const pose = flightController.update(delta);
        const ambientOffsets = flightController.getAmbientOffsets();

        birbAnchor.position.copy(pose.position).add(ambientOffsets.position);
        birbAnchor.quaternion.copy(pose.quaternion);
        birbAnchor.quaternion.multiply(modelOrientationOffset);
        blendedQuaternion.copy(ambientOffsets.quaternion);
        birbAnchor.quaternion.multiply(blendedQuaternion);
        birbAnchor.quaternion.normalize();

        if (glideTrail && glideTrail.rotation) {
          glideTrail.rotation.z = motionState.elapsed * 0.32;
        }

        if (motionState.animate && !controlState.systemPaused) {
          updateControlMetrics(flightController.getSpeed());
        }

        updateFpsReadout(time);
        cameraState.updateActiveCamera({ pose, ambientOffsets, delta });
        renderer.render(scene, cameraState.camera);
      };

      function handleContextLost(event) {
        event.preventDefault();
        contextState.lost = true;
        previousTime = null;
        flightControls?.reset?.({ releasePointerLock: true });
        renderer.setAnimationLoop(null);
        if (statusMetric) {
          statusMetric.textContent = "Graphics context lost — attempting to restore...";
        }
      }

      function handleContextRestored() {
        contextState.lost = false;
        renderer.state?.reset?.();
        invalidateRendererSize();
        updateRendererSize(true);
        renderer.setAnimationLoop(document.hidden ? null : renderFrame);
        renderFrame(0);
        if (statusMetric) {
          statusMetric.textContent = "Graphics restored. Ready to fly.";
        }
      }

      canvas.addEventListener("webglcontextlost", handleContextLost, false);
      canvas.addEventListener("webglcontextrestored", handleContextRestored, false);

      renderer.setAnimationLoop(renderFrame);

      if (statusMetric) {
        statusMetric.textContent = "Ready to fly! Use touch controls or arrow keys.";
      }

      document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          previousTime = null;
          flightControls.reset({ releasePointerLock: true });
          fpsState.lastSampleTime = null;
          fpsState.frames = 0;
          if (fpsMetric) {
            fpsMetric.textContent = "--";
          }
        } else {
          flightControls.reset();
        }
        renderer.setAnimationLoop(document.hidden ? null : renderFrame);
      });

      window.addEventListener("beforeunload", () => {
        renderer.setAnimationLoop(null);
        if (resizeObserver) {
          resizeObserver.disconnect();
        }
        if (cameraState) {
          cameraState.dispose();
        }
        renderer.dispose();
        if (environmentShell) {
          environmentShell.dispose();
          environmentShell = null;
        }
        flightControls.dispose();
      });

      invalidateRendererSize();
      updateRendererSize(true);
      renderFrame(0);
    </script>
  </body>
</html>
