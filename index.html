<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Birb Flight Lab</title>
  <meta name="description" content="Mobile-first Three.js playground for experimenting with gliding birbs." />
  <meta name="theme-color" content="#0b0d17" />
  <link rel="icon" href="/favicon.svg" type="image/svg+xml" />
  <style>
    :root {
      color-scheme: dark;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      --space-2: clamp(0.75rem, 1.5vw + 0.35rem, 1.1rem);
      --space-3: clamp(1rem, 1.5vw + 0.6rem, 1.5rem);
      --space-4: clamp(1.25rem, 2vw + 0.75rem, 1.9rem);
      --max-width: min(92vw, 42rem);
      --header-size: clamp(0.75rem, 1vw + 0.65rem, 1.1rem);
      --status-size: clamp(0.6rem, 0.7vw + 0.55rem, 0.75rem);
      background-color: #0a1324;
    }

    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    html {
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }

    body {
      margin: 0;
      min-height: 100vh;
      min-height: 100dvh;
      display: flex;
      align-items: stretch;
      justify-content: center;
      background: radial-gradient(circle at 30% 20%, #273d68, #0a1324 68%);
      color: #f6f8ff;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }

    main {
      width: 100%;
      max-width: var(--max-width);
      display: flex;
      flex-direction: column;
      gap: var(--space-3);
      padding: var(--space-3) var(--space-3) calc(var(--space-3) + 3rem);
    }

    header {
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      font-size: var(--header-size);
      opacity: 0.75;
    }

    .canvas-wrapper {
      position: relative;
      flex: 1;
      min-height: clamp(18rem, 62vw, 32rem);
      border-radius: 1.5rem;
      overflow: hidden;
      backdrop-filter: blur(16px);
      border: 1px solid rgba(186, 210, 255, 0.12);
      box-shadow: 0 26px 56px rgba(6, 14, 29, 0.6);
      padding-bottom: clamp(2.5rem, 16vw, 5.25rem);
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: transparent;
      touch-action: none;
    }

    .heading-telemetry {
      position: fixed;
      inset: 0.85rem auto auto 0.85rem;
      z-index: 20;
      min-width: 15rem;
      padding: 0.75rem 0.9rem;
      border-radius: 0.9rem;
      border: 1px solid rgba(144, 188, 255, 0.35);
      background: rgba(10, 17, 34, 0.9);
      box-shadow: 0 12px 28px rgba(3, 8, 20, 0.5);
      font-size: 0.8rem;
      line-height: 1.35;
      letter-spacing: 0.04em;
      color: #eaf2ff;
      backdrop-filter: blur(14px);
    }

    .heading-telemetry h3 {
      margin: 0 0 0.35rem;
      font-size: 0.72rem;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      opacity: 0.8;
    }

    .heading-telemetry dl {
      margin: 0;
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 0.25rem 0.6rem;
    }

    .heading-telemetry dt {
      opacity: 0.72;
    }

    .heading-telemetry dd {
      margin: 0;
      font-variant-numeric: tabular-nums;
      text-align: right;
    }

    .touch-controls {
      position: absolute;
      inset: 0;
      display: none;
      justify-content: stretch;
      align-items: stretch;
      padding: 0;
      pointer-events: none;
      z-index: 1;
    }

    .touch-controls__zone {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      border-radius: 0;
      background: transparent;
      border: none;
      box-shadow: none;
      display: flex;
      align-items: flex-end;
      justify-content: flex-start;
      padding: var(--space-2);
      pointer-events: auto;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }

    .touch-controls__zone.has-dynamic-joystick {
      justify-content: flex-start;
    }

    .thumbstick {
      position: relative;
      width: clamp(5.5rem, 28vw, 7.25rem);
      aspect-ratio: 1;
      border-radius: 50%;
      background: transparent;
      border: none;
      box-shadow: none;
      touch-action: none;
      user-select: none;
    }

    .thumbstick::before {
      display: none;
    }

    .thumbstick__handle {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 42%;
      aspect-ratio: 1;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #d8e7ff, #7ba6ff 60%, #345cae 100%);
      border: 1px solid rgba(204, 224, 255, 0.7);
      box-shadow: 0 10px 24px rgba(10, 17, 34, 0.62);
      transform: translate(calc(-50% + var(--thumbstick-offset-x, 0px)), calc(-50% + var(--thumbstick-offset-y, 0px)));
      transition: transform 160ms ease;
    }

    .touch-controls__zone.has-dynamic-joystick .thumbstick {
      pointer-events: none;
      opacity: 0;
      visibility: hidden;
      transition: opacity 180ms ease, visibility 180ms ease;
    }

    .touch-controls__zone.has-dynamic-joystick .thumbstick::after {
      content: '';
      position: absolute;
      inset: -4px;
      border-radius: 50%;
      border: 2px dashed rgba(170, 200, 255, 0.35);
      pointer-events: none;
    }

    .touch-controls__zone.has-dynamic-joystick .thumbstick .thumbstick__handle {
      opacity: 0.6;
    }

    .touch-controls__zone.has-dynamic-joystick .thumbstick.is-hidden {
      opacity: 0;
    }

    .thumbstick.is-active .thumbstick__handle {
      transition: none;
    }

    .thumbstick {
      opacity: 1;
      pointer-events: auto;
    }

    .thumbstick.is-active {
      opacity: 1;
    }

    .lift-controls {
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
      align-items: center;
      justify-content: center;
    }

    .lift-button {
      appearance: none;
      border: 1px solid rgba(176, 209, 255, 0.36);
      border-radius: 999px;
      padding: 0.4rem 1rem;
      font-size: 0.65rem;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #f3f7ff;
      background: linear-gradient(135deg, rgba(64, 105, 184, 0.58), rgba(26, 44, 92, 0.9));
      box-shadow: inset 0 0 0 1px rgba(32, 62, 124, 0.45);
      touch-action: none;
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      min-width: clamp(3.6rem, 18vw, 4.75rem);
      text-align: center;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .lift-button__icon {
      font-size: 1.15rem;
      line-height: 1;
    }

    .lift-button.is-active,
    .lift-button:active {
      box-shadow: inset 0 0 0 1px rgba(118, 162, 230, 0.65), 0 8px 18px rgba(9, 16, 34, 0.55);
      border-color: rgba(206, 230, 255, 0.75);
    }

    .canvas-actions {
      position: absolute;
      inset: auto var(--space-2) var(--space-2) auto;
      z-index: 3;
      padding: 0.55rem;
      border-radius: 1.1rem;
      background: rgba(14, 23, 41, 0.76);
      border: 1px solid rgba(132, 174, 255, 0.3);
      box-shadow: 0 16px 42px rgba(6, 14, 31, 0.55);
      backdrop-filter: blur(18px);
      touch-action: none;
      cursor: grab;
      transition: box-shadow 180ms ease;
    }

    .canvas-actions:is(:hover, :focus-within) {
      box-shadow: 0 20px 46px rgba(7, 15, 34, 0.6);
    }

    .canvas-actions.is-dragging {
      cursor: grabbing;
    }

    .canvas-actions__tray {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.45rem;
    }

    .canvas-action-button {
      padding: 0;
      width: 2.6rem;
      min-width: 2.6rem;
      min-height: 2.6rem;
      border-radius: 0.85rem;
      background: linear-gradient(145deg, rgba(30, 47, 84, 0.9), rgba(20, 31, 56, 0.78));
      border: 1px solid rgba(158, 196, 255, 0.32);
      color: #f1f5ff;
      font-size: 0.66rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 12px 28px rgba(7, 14, 30, 0.55);
      backdrop-filter: blur(18px);
      -webkit-touch-callout: none;
      user-select: none;
      -webkit-user-select: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.35rem;
      transition: transform 150ms ease, box-shadow 150ms ease, border-color 150ms ease,
        background 180ms ease;
    }

    .canvas-action-button svg {
      width: 1.1rem;
      height: 1.1rem;
      display: block;
    }

    .environment-toggle__icon,
    .fullscreen-toggle__icon {
      fill: none;
      stroke: currentColor;
      stroke-width: 1.35;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    .environment-toggle__icon path:first-of-type {
      stroke-width: 1.25;
    }

    .canvas-action-button:focus-visible {
      outline: 2px solid rgba(124, 170, 255, 0.75);
      outline-offset: 2px;
    }

    .canvas-action-button:not([disabled]):hover {
      box-shadow: 0 16px 34px rgba(8, 15, 33, 0.6);
      border-color: rgba(198, 224, 255, 0.7);
      background: linear-gradient(145deg, rgba(38, 59, 102, 0.98), rgba(24, 37, 66, 0.88));
    }

    .canvas-action-button:not([disabled]):active {
      transform: translateY(1px);
    }

    .fullscreen-toggle,
    .environment-toggle {
      border-color: rgba(124, 170, 255, 0.28);
    }

    .fullscreen-toggle svg[hidden] {
      display: none;
    }

    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    /* Fullscreen mode - simplified fixed positioning approach */
    body.is-fullscreen {
      overflow: hidden;
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
    }

    .canvas-wrapper.is-fullscreen {
      position: fixed;
      inset: 0;
      z-index: 9999;
      max-width: none;
      width: 100%;
      height: 100%;
      min-height: 0;
      border-radius: 0;
      border: none;
      box-shadow: none;
      background: #0a1324;
      padding: 0;
    }

    .canvas-wrapper.is-fullscreen canvas {
      width: 100%;
      height: 100%;
    }

    .canvas-wrapper.is-fullscreen .touch-controls {
      bottom: max(env(safe-area-inset-bottom, 0), var(--space-2));
      left: env(safe-area-inset-left, 0);
      right: env(safe-area-inset-right, 0);
    }

    /* Native fullscreen (desktop) */
    .canvas-wrapper:fullscreen,
    .canvas-wrapper:-webkit-full-screen {
      max-width: none;
      border-radius: 0;
      border: none;
      box-shadow: none;
      padding-bottom: clamp(3rem, 14vw, 4.5rem);
    }

    @media (pointer: coarse) {
      .touch-controls {
        display: grid;
      }
    }

    noscript {
      position: fixed;
      inset: auto 0 0 0;
      padding: 1rem;
      text-align: center;
      font-size: 0.85rem;
      background: rgba(6, 9, 18, 0.92);
      color: #eff2fc;
    }

    /* Nest Mode UI */
    .nest-ui {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 10;
      opacity: 0;
      transition: opacity 300ms ease;
    }

    .nest-ui.is-visible {
      opacity: 1;
    }

    .nest-ui.is-visible .nest-button {
      pointer-events: auto;
    }

    .nest-crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 40px;
      height: 40px;
    }

    .nest-crosshair::before,
    .nest-crosshair::after {
      content: '';
      position: absolute;
      background: rgba(255, 100, 80, 0.9);
      box-shadow: 0 0 8px rgba(255, 80, 60, 0.6);
    }

    .nest-crosshair::before {
      width: 2px;
      height: 100%;
      left: 50%;
      transform: translateX(-50%);
    }

    .nest-crosshair::after {
      width: 100%;
      height: 2px;
      top: 50%;
      transform: translateY(-50%);
    }

    .nest-crosshair-dot {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: rgba(255, 120, 100, 0.95);
      box-shadow: 0 0 10px rgba(255, 80, 60, 0.8);
    }

    .nest-button {
      position: absolute;
      appearance: none;
      border: 2px solid rgba(255, 140, 100, 0.6);
      border-radius: 50%;
      width: clamp(3.5rem, 14vw, 4.5rem);
      height: clamp(3.5rem, 14vw, 4.5rem);
      background: linear-gradient(145deg, rgba(180, 80, 50, 0.85), rgba(120, 40, 30, 0.9));
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4), inset 0 0 0 1px rgba(255, 180, 150, 0.2);
      color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 150ms ease, box-shadow 150ms ease, border-color 150ms ease;
      touch-action: none;
      -webkit-touch-callout: none;
      user-select: none;
    }

    .nest-button:active {
      transform: scale(0.95);
    }

    .nest-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .nest-button svg {
      width: 55%;
      height: 55%;
      fill: currentColor;
    }

    .nest-takeoff-button {
      bottom: clamp(1rem, 4vw, 2rem);
      right: clamp(1rem, 4vw, 2rem);
    }

    .nest-launch-button {
      bottom: clamp(1rem, 4vw, 2rem);
      left: clamp(1rem, 4vw, 2rem);
    }

    .nest-launch-button .cooldown-ring {
      position: absolute;
      inset: -4px;
      border-radius: 50%;
      border: 3px solid transparent;
      border-top-color: rgba(255, 200, 150, 0.9);
      transform: rotate(0deg);
      transition: transform 0.1s linear;
    }

    .nest-launch-button.is-cooling .cooldown-ring {
      animation: cooldown-spin 5s linear;
    }

    @keyframes cooldown-spin {
      from {
        transform: rotate(0deg);
      }

      to {
        transform: rotate(360deg);
      }
    }

    .nest-toast {
      position: absolute;
      top: 15%;
      left: 50%;
      transform: translateX(-50%);
      padding: 0.75rem 1.5rem;
      background: rgba(20, 30, 50, 0.9);
      border: 1px solid rgba(255, 140, 100, 0.4);
      border-radius: 1rem;
      color: rgba(255, 230, 210, 0.95);
      font-size: clamp(0.75rem, 2.5vw, 0.9rem);
      text-align: center;
      max-width: 90%;
      opacity: 0;
      transition: opacity 400ms ease;
      pointer-events: none;
    }

    .nest-toast.is-visible {
      opacity: 1;
    }

    .nest-indicator {
      position: absolute;
      bottom: clamp(1rem, 4vw, 2rem);
      left: 50%;
      transform: translateX(-50%);
      padding: 0.5rem 1rem;
      background: rgba(255, 80, 50, 0.15);
      border: 1px solid rgba(255, 100, 70, 0.4);
      border-radius: 2rem;
      color: rgba(255, 180, 150, 0.95);
      font-size: clamp(0.65rem, 2vw, 0.75rem);
      font-family: inherit;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      opacity: 0;
      transition: opacity 300ms ease, transform 150ms ease, background 150ms ease;
      pointer-events: none;
      z-index: 11;
      cursor: pointer;
      touch-action: none;
      -webkit-touch-callout: none;
      user-select: none;
    }

    .nest-indicator.is-visible {
      opacity: 1;
      pointer-events: auto;
    }

    .nest-indicator:active {
      transform: translateX(-50%) scale(0.95);
      background: rgba(255, 80, 50, 0.3);
    }

    /* Freeze indicator - shows when birb collides with drone */
    .freeze-indicator {
      position: fixed;
      bottom: 20%;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
      z-index: 100;
    }

    .freeze-indicator.is-visible {
      opacity: 1;
    }

    .freeze-indicator.is-frozen {
      animation: freeze-pulse 0.5s ease-in-out infinite;
    }

    @keyframes freeze-pulse {
      0%, 100% { transform: translateX(-50%) scale(1); }
      50% { transform: translateX(-50%) scale(1.1); }
    }

    .freeze-progress-ring {
      width: 64px;
      height: 64px;
    }

    .freeze-progress-ring svg {
      transform: rotate(-90deg);
      width: 100%;
      height: 100%;
    }

    .freeze-bg {
      fill: none;
      stroke: rgba(100, 200, 255, 0.3);
      stroke-width: 3;
    }

    .freeze-progress {
      fill: none;
      stroke: #4dc3ff;
      stroke-width: 3;
      stroke-linecap: round;
      stroke-dasharray: 100, 100;
      stroke-dashoffset: 0;
      transition: stroke-dashoffset 0.1s linear;
    }

    .freeze-icon {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 24px;
      color: #4dc3ff;
      text-shadow: 0 0 10px rgba(77, 195, 255, 0.8);
    }

    @media (min-width: 48rem) {
      main {
        padding-bottom: calc(var(--space-4) + 5.5rem);
      }

      .canvas-wrapper {
        min-height: clamp(24rem, 55vh, 38rem);
        border-radius: 2rem;
        padding-bottom: clamp(2rem, 8vw, 3.5rem);
      }

      .touch-controls {
        display: none;
      }

      .canvas-actions {
        padding: 0.65rem;
      }

      .canvas-actions__tray {
        gap: 0.55rem;
      }
    }

    /* Splash Screen */
    .splash-screen {
      position: fixed;
      inset: 0;
      z-index: 10000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: #060918;
      cursor: pointer;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }

    .splash-screen.is-hidden {
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease-out;
    }

    .splash-image {
      max-width: 90%;
      max-height: 70vh;
      object-fit: contain;
      border-radius: 1rem;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
    }

    .splash-prompt {
      margin-top: 2rem;
      font-size: clamp(1rem, 4vw, 1.5rem);
      color: rgba(200, 220, 255, 0.9);
      text-transform: uppercase;
      letter-spacing: 0.2em;
      animation: splash-pulse 2s ease-in-out infinite;
    }

    @keyframes splash-pulse {
      0%, 100% { opacity: 0.6; }
      50% { opacity: 1; }
    }
  </style>
</head>

<body>
  <!-- Splash Screen - tap to dismiss -->
  <div class="splash-screen" data-splash-screen>
    <img src="./splash.jpg" alt="Birb Flight Lab" class="splash-image">
    <div class="splash-prompt">Tap to start</div>
  </div>

  <main>
    <header>Birb Flight Lab</header>
    <div class="canvas-wrapper">
      <canvas id="scene" role="img" aria-label="Stylized blue bird gliding through a dark sky"></canvas>
      <div class="canvas-actions" data-draggable-panel>
        <div class="canvas-actions__tray" role="group" aria-label="Display options">
          <button type="button" class="canvas-action-button environment-toggle" data-control="environment-toggle"
            aria-label="Cycle environment">
            <svg class="environment-toggle__icon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path d="M12 20.25a8.25 8.25 0 1 0 0-16.5 8.25 8.25 0 0 0 0 16.5Z" />
              <path d="M3.9 9.75h16.2m-16.2 4.5h16.2" />
              <path
                d="M12 3.75c2.3 2.4 3.45 5.4 3.45 8.25S14.3 17.85 12 20.25m0-16.5c-2.3 2.4-3.45 5.4-3.45 8.25S9.7 17.85 12 20.25" />
            </svg>
            <span class="visually-hidden" data-environment-label>Environment: Forest</span>
          </button>
          <button type="button" class="canvas-action-button fullscreen-toggle" data-control="fullscreen"
            aria-pressed="false" aria-label="Enter fullscreen">
            <svg class="fullscreen-toggle__icon" viewBox="0 0 24 24" aria-hidden="true" focusable="false"
              data-icon="enter">
              <path d="M9 5H5v4M15 5h4v4M9 19H5v-4M15 19h4v-4" stroke-linecap="round" stroke-linejoin="round" />
            </svg>
            <svg class="fullscreen-toggle__icon" viewBox="0 0 24 24" aria-hidden="true" focusable="false"
              data-icon="exit" hidden>
              <path d="M9 7H7V5M17 7V5h-2M9 17v2H7M17 17h-2v2" stroke-linecap="round" stroke-linejoin="round" />
              <path d="M15 9h4M15 15h4M5 9h4M5 15h4" stroke-linecap="round" stroke-linejoin="round" />
            </svg>
            <span class="visually-hidden" data-fullscreen-label>Enter Fullscreen</span>
          </button>
        </div>
      </div>
      <div class="touch-controls" aria-hidden="true">
        <div class="touch-controls__zone" data-touch-zone>
          <div class="thumbstick" data-thumbstick="left">
            <div class="thumbstick__handle" data-thumbstick-handle></div>
          </div>
        </div>
      </div>

      <!-- Nest Mode UI -->
      <div class="nest-ui" data-nest-ui aria-hidden="true">
        <!-- Crosshair -->
        <div class="nest-crosshair">
          <div class="nest-crosshair-dot"></div>
        </div>

        <!-- Take Off Button (bottom right) - Wing icon -->
        <button type="button" class="nest-button nest-takeoff-button" data-nest-takeoff aria-label="Take off from nest">
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path
              d="M21 16v-2l-8-5V3.5a1.5 1.5 0 0 0-3 0V9l-8 5v2l8-2.5V19l-2 1.5V22l3.5-1 3.5 1v-1.5L13 19v-5.5l8 2.5Z" />
          </svg>
        </button>

        <!-- Launch Button (bottom left) - Rocket icon -->
        <button type="button" class="nest-button nest-launch-button" data-nest-launch aria-label="Launch rocket">
          <div class="cooldown-ring"></div>
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path
              d="M12 2.5c1.5 0 5.5 3 5.5 10S13.5 21.5 12 21.5 6.5 15.5 6.5 12.5s4-10 5.5-10Zm0 4a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3Zm-3 12h6l-1 3h-4l-1-3Z" />
          </svg>
        </button>

        <!-- Toast message -->
        <div class="nest-toast" data-nest-toast>
          You've landed at a nest! Look around and launch rockets.
        </div>
      </div>

      <!-- Nest proximity indicator (shows when approaching) -->
      <button type="button" class="nest-indicator" data-nest-indicator aria-label="Land on nest">
        Nest nearby - Tap to land
      </button>

      <!-- Freeze indicator (shows when birb collides with drone) -->
      <div class="freeze-indicator" data-freeze-indicator aria-hidden="true">
        <div class="freeze-progress-ring">
          <svg viewBox="0 0 36 36">
            <path class="freeze-bg" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831"/>
            <path class="freeze-progress" data-freeze-progress d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831"/>
          </svg>
        </div>
        <span class="freeze-icon">&#x2744;</span>
      </div>
    </div>
  </main>
  <noscript>Enable JavaScript to view the Birb Flight Lab experience.</noscript>

  <script type="module">
    // Global error handler for mobile debugging
    window.addEventListener("error", (event) => {
      const statusEl = document.querySelector('[data-metric="status"]');
      if (statusEl) {
        statusEl.textContent = `Error: ${event.message || "Unknown error"}`;
      }
      console.error("Global error:", event);
    });

    window.addEventListener("unhandledrejection", (event) => {
      const statusEl = document.querySelector('[data-metric="status"]');
      if (statusEl) {
        statusEl.textContent = `Load error: ${event.reason?.message || "Module failed to load"}`;
      }
      console.error("Unhandled rejection:", event);
    });

    // Splash screen - dismiss on tap/click
    const splashScreen = document.querySelector('[data-splash-screen]');
    if (splashScreen) {
      const dismissSplash = () => {
        splashScreen.classList.add('is-hidden');
        // Remove from DOM after fade animation
        setTimeout(() => {
          splashScreen.remove();
        }, 500);
      };
      splashScreen.addEventListener('click', dismissSplash, { once: true });
      splashScreen.addEventListener('touchend', (e) => {
        e.preventDefault();
        dismissSplash();
      }, { once: true, passive: false });
    }

    let THREE,
      GLTFLoader,
      FreeFlightController,
      createCameraState,
      CAMERA_MODES = { FOLLOW: 'follow', FPV: 'fpv' },
      createFlightControls,
      AimRig,
      createWorldShell,
      ENVIRONMENT_VARIANTS,
      getEnvironmentDefinition,
      nipplejs,
      BirdFlight, BirdCamera, BirdVisual, createTouchInput, createKeyboardInput, combineInputs;

    try {
      THREE = await import("https://esm.sh/three@0.161.0");
      const flightModule = await import("./free-flight-controller.js");
      FreeFlightController = flightModule.FreeFlightController;

      // New Flight System Imports
      const birdFlightMod = await import("./src/flight/bird-flight.js");
      BirdFlight = birdFlightMod.BirdFlight;
      const birdCameraMod = await import("./src/flight/bird-camera.js");
      BirdCamera = birdCameraMod.BirdCamera;
      const birdVisualMod = await import("./src/flight/bird-visual.js");
      BirdVisual = birdVisualMod.BirdVisual;
      const touchInputMod = await import("./src/flight/touch-input.js");
      createTouchInput = touchInputMod.createTouchInput;
      createKeyboardInput = touchInputMod.createKeyboardInput;
      combineInputs = touchInputMod.combineInputs;
      const cameraModule = await import("./src/camera/camera-state.js");
      createCameraState = cameraModule.createCameraState;
      CAMERA_MODES = cameraModule.CAMERA_MODES;
      const controlsModule = await import("./src/controls/flight-controls.js");
      createFlightControls = controlsModule.createFlightControls;
      const worldModule = await import("./src/environment/world-shell.js");
      createWorldShell = worldModule.createWorldShell;
      ENVIRONMENT_VARIANTS = worldModule.ENVIRONMENT_VARIANTS;
      getEnvironmentDefinition = worldModule.getEnvironmentDefinition;
      const sphericalWorldModule = await import("./src/environment/spherical-world.js");
      var createSphericalWorld = sphericalWorldModule.createSphericalWorld;
      var SPHERE_RADIUS = sphericalWorldModule.SPHERE_RADIUS;

      // Nesting system imports
      const nestPointsModule = await import("./src/nesting/nest-points.js");
      var createNestPointsSystem = nestPointsModule.createNestPointsSystem;
      var NEST_PROXIMITY_RANGE = nestPointsModule.NEST_PROXIMITY_RANGE;
      const nestingSystemModule = await import("./src/nesting/nesting-system.js");
      var createNestingSystem = nestingSystemModule.createNestingSystem;
      var NESTING_STATES = nestingSystemModule.NESTING_STATES;
      const aimRigModule = await import("./src/nesting/aim-rig.js");
      AimRig = aimRigModule.AimRig;
      const rocketModule = await import("./src/nesting/rocket.js");
      var createRocketSystem = rocketModule.createRocketSystem;
      const droneModule = await import("./src/nesting/drone-system.js");
      var createDroneSystem = droneModule.createDroneSystem;
      const gltfLoaderModule = await import(
        "https://esm.sh/three@0.161.0/examples/jsm/loaders/GLTFLoader.js"
      );
      GLTFLoader = gltfLoaderModule.GLTFLoader;
      try {
        const nippleModule = await import("https://esm.sh/nipplejs@0.10.1");
        nipplejs = nippleModule?.default ?? nippleModule;
      } catch (nippleImportError) {
        console.warn("Failed to load nipplejs:", nippleImportError);
      }
    } catch (importError) {
      const statusEl = document.querySelector('[data-metric="status"]');
      if (statusEl) {
        statusEl.textContent = `Failed to load modules: ${importError.message}`;
      }
      console.error("Import error:", importError);
      throw importError;
    }

    // Update status after successful module load
    {
      const statusEl = document.querySelector('[data-metric="status"]');
      if (statusEl) {
        statusEl.textContent = "Modules loaded. Initializing renderer...";
      }
    }

    const canvasWrapper = document.querySelector(".canvas-wrapper");
    const canvasActions = document.querySelector("[data-draggable-panel]");
    const canvas = document.querySelector("#scene");

    const statusMetric = document.querySelector('[data-metric="status"]');

    const showFatalError = (message) => {
      if (statusMetric) {
        statusMetric.textContent = message;
      }
      throw new Error(message);
    };

    let renderer;
    try {
      renderer = new THREE.WebGLRenderer({
        canvas,
        antialias: true,
        alpha: true,
        powerPreference: "low-power",
        failIfMajorPerformanceCaveat: false,
      });
    } catch (error) {
      showFatalError("Unable to start WebGL — your browser may not support it.");
    }

    if (!renderer?.getContext()) {
      showFatalError("WebGL context unavailable. Please enable hardware acceleration.");
    }

    if (statusMetric) {
      statusMetric.textContent = "Renderer ready. Building scene...";
    }

    const contextState = { lost: false };

    const prefersCoarsePointer = window.matchMedia("(pointer: coarse)").matches;
    const DPR_CAP = prefersCoarsePointer ? 1.4 : 1.8;
    const resizeState = {
      width: 0,
      height: 0,
      pixelRatio: 1,
      dirty: true,
    };
    const actionPaletteState = {
      pointerId: null,
      offsetX: 0,
      offsetY: 0,
      width: 0,
      height: 0,
      hasCustomPosition: false,
      relativeX: 0,
      relativeY: 0,
    };

    // ============ AUDIO SYSTEM (Preloaded for instant playback) ============
    let audioUnlocked = false;

    // Preload audio files for instant playback (no loading delay)
    const SOUND_POOL_SIZE = 3; // Multiple instances for overlapping sounds
    const preloadedSounds = {
      rocketFire: [],
      explosion: [],
    };

    // Create audio pool for a sound
    const createSoundPool = (src, poolSize, volume) => {
      const pool = [];
      for (let i = 0; i < poolSize; i++) {
        const audio = new Audio(src);
        audio.volume = volume;
        audio.preload = 'auto';
        pool.push({ audio, playing: false });
      }
      return pool;
    };

    // Initialize sound pools (preload immediately)
    const initSoundPools = () => {
      preloadedSounds.rocketFire = createSoundPool('/sound/rocket-fire.mp3', SOUND_POOL_SIZE, 0.6);
      preloadedSounds.explosion = createSoundPool('/sound/explosion.mp3', SOUND_POOL_SIZE, 0.7);
    };
    initSoundPools();

    // Play from preloaded pool (instant, no loading delay)
    const playFromPool = (pool) => {
      // Find an available audio element
      let slot = pool.find(s => !s.playing);
      if (!slot) {
        // All slots busy, reuse the first one
        slot = pool[0];
        slot.audio.currentTime = 0;
      }

      slot.playing = true;
      slot.audio.currentTime = 0;
      slot.audio.play().then(() => {
        // Mark as available when done
        slot.audio.addEventListener('ended', () => {
          slot.playing = false;
        }, { once: true });
      }).catch(() => {
        slot.playing = false;
      });
    };

    // Unlock audio on first user interaction (required for iOS)
    const unlockAudio = () => {
      if (audioUnlocked) return;
      // Play silent audio to unlock
      const silence = new Audio('data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=');
      silence.play().then(() => {
        silence.pause();
        audioUnlocked = true;
        // Also "warm up" the preloaded sounds by playing them silently
        preloadedSounds.rocketFire.forEach(s => { s.audio.volume = 0; s.audio.play().then(() => { s.audio.pause(); s.audio.currentTime = 0; s.audio.volume = 0.6; }).catch(() => {}); });
        preloadedSounds.explosion.forEach(s => { s.audio.volume = 0; s.audio.play().then(() => { s.audio.pause(); s.audio.currentTime = 0; s.audio.volume = 0.7; }).catch(() => {}); });
      }).catch(() => {});
    };

    // Unlock on any user interaction
    ['touchstart', 'touchend', 'mousedown', 'click', 'keydown'].forEach(event => {
      document.addEventListener(event, unlockAudio, { passive: true, once: false });
    });

    // Play rocket fire sound (instant from preloaded pool)
    const playRocketFireSound = () => {
      playFromPool(preloadedSounds.rocketFire);
    };

    // Play explosion sound (instant from preloaded pool)
    const playExplosionSound = () => {
      playFromPool(preloadedSounds.explosion);
    };

    function clamp(value, min, max) {
      if (!Number.isFinite(value)) {
        return 0;
      }
      return Math.min(Math.max(value, min), max);
    }

    function repositionActionPalette() {
      if (!canvasActions || !canvasWrapper || !actionPaletteState.hasCustomPosition)
        return;
      const wrapperRect = canvasWrapper.getBoundingClientRect();
      const width = canvasActions.offsetWidth;
      const height = canvasActions.offsetHeight;
      const maxX = Math.max(0, wrapperRect.width - width);
      const maxY = Math.max(0, wrapperRect.height - height);
      const left = clamp(actionPaletteState.relativeX * maxX, 0, maxX);
      const top = clamp(actionPaletteState.relativeY * maxY, 0, maxY);
      canvasActions.style.left = `${left}px`;
      canvasActions.style.top = `${top}px`;
      canvasActions.style.right = "auto";
      canvasActions.style.bottom = "auto";
    }

    if (canvasActions && canvasWrapper) {
      const dragListenerOptions = { passive: false };

      const handlePointerDown = (event) => {
        if (event.button !== 0 && event.pointerType !== "touch") return;
        const target = event.target;
        if (target && target.closest("button")) return;
        const actionsRect = canvasActions.getBoundingClientRect();
        actionPaletteState.pointerId = event.pointerId;
        actionPaletteState.offsetX = event.clientX - actionsRect.left;
        actionPaletteState.offsetY = event.clientY - actionsRect.top;
        actionPaletteState.width = actionsRect.width;
        actionPaletteState.height = actionsRect.height;
        canvasActions.classList.add("is-dragging");
        if (typeof canvasActions.setPointerCapture === "function") {
          try {
            canvasActions.setPointerCapture(event.pointerId);
          } catch (error) {
            // Ignore pointer capture errors in unsupported browsers.
          }
        }
        event.preventDefault();
      };

      const handlePointerMove = (event) => {
        if (actionPaletteState.pointerId !== event.pointerId) return;
        event.preventDefault();
        const wrapperRect = canvasWrapper.getBoundingClientRect();
        const width = canvasActions.offsetWidth;
        const height = canvasActions.offsetHeight;
        const maxX = Math.max(0, wrapperRect.width - width);
        const maxY = Math.max(0, wrapperRect.height - height);
        const rawLeft = event.clientX - actionPaletteState.offsetX - wrapperRect.left;
        const rawTop = event.clientY - actionPaletteState.offsetY - wrapperRect.top;
        const clampedLeft = clamp(rawLeft, 0, maxX);
        const clampedTop = clamp(rawTop, 0, maxY);
        canvasActions.style.left = `${clampedLeft}px`;
        canvasActions.style.top = `${clampedTop}px`;
        canvasActions.style.right = "auto";
        canvasActions.style.bottom = "auto";
        actionPaletteState.width = width;
        actionPaletteState.height = height;
        actionPaletteState.hasCustomPosition = true;
        actionPaletteState.relativeX = maxX > 0 ? clampedLeft / maxX : 0;
        actionPaletteState.relativeY = maxY > 0 ? clampedTop / maxY : 0;
      };

      const handlePointerEnd = (event) => {
        if (actionPaletteState.pointerId !== event.pointerId) return;
        if (
          typeof canvasActions.hasPointerCapture === "function" &&
          canvasActions.hasPointerCapture(event.pointerId) &&
          typeof canvasActions.releasePointerCapture === "function"
        ) {
          canvasActions.releasePointerCapture(event.pointerId);
        }
        canvasActions.classList.remove("is-dragging");
        actionPaletteState.pointerId = null;
        event.preventDefault();
      };

      canvasActions.addEventListener("pointerdown", handlePointerDown, dragListenerOptions);
      canvasActions.addEventListener("pointermove", handlePointerMove, dragListenerOptions);
      ["pointerup", "pointercancel", "lostpointercapture"].forEach((eventName) => {
        canvasActions.addEventListener(eventName, handlePointerEnd, dragListenerOptions);
      });

      window.addEventListener("resize", repositionActionPalette, { passive: true });
    }

    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.22;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050a14);
    // Extended fog for spherical world visibility (sphere radius is 30)
    scene.fog = new THREE.Fog(0x050a14, 40, 200);

    const ambient = new THREE.HemisphereLight(0xd4f1ff, 0x1a2f32, 0.92);
    ambient.groundColor.set(0x1a2f32);
    scene.add(ambient);

    const keyLight = new THREE.DirectionalLight(0xf3f0d2, 1.2);
    keyLight.position.set(7.5, 8.2, 5.2);
    scene.add(keyLight);

    const rimLight = new THREE.DirectionalLight(0x78b6ff, 0.48);
    rimLight.position.set(-6.2, 5.1, -5.4);
    scene.add(rimLight);

    const fillLight = new THREE.DirectionalLight(0x9fc8ff, 0.38);
    fillLight.position.set(1.2, 3.1, -6.2);
    scene.add(fillLight);

    const glowLight = new THREE.PointLight(0x63d0ff, 1.35, 12, 2.1);
    glowLight.position.set(0.3, 1.6, 0.8);
    scene.add(glowLight);

    const lightingRig = { ambient, keyLight, rimLight, fillLight, glowLight };

    const debugVectorState = (() => {
      const hasDebugVectors = new URLSearchParams(window.location.search).has("debugVectors");
      if (!hasDebugVectors) return null;

      const modelForwardHelper = new THREE.ArrowHelper(
        new THREE.Vector3(0, 0, -1),
        new THREE.Vector3(),
        1,
        0x4ad8ff,
        0.32,
        0.14
      );
      const cameraForwardHelper = new THREE.ArrowHelper(
        new THREE.Vector3(0, 0, -1),
        new THREE.Vector3(),
        1,
        0xffd166,
        0.32,
        0.14
      );
      const velocityHelper = new THREE.ArrowHelper(
        new THREE.Vector3(0, 0, -1),
        new THREE.Vector3(),
        1,
        0xff61d8,
        0.32,
        0.14
      );

      scene.add(modelForwardHelper, cameraForwardHelper, velocityHelper);

      const scratch = {
        direction: new THREE.Vector3(),
        origin: new THREE.Vector3(),
      };

      const setArrow = (helper, direction, origin, length) => {
        const fallbackLength = 0.35;
        if (direction.lengthSq() < 1e-8) {
          scratch.direction.set(0, 0, -1);
        } else {
          scratch.direction.copy(direction).normalize();
        }
        helper.setDirection(scratch.direction);
        const resolvedLength = Math.max(length ?? direction.length(), fallbackLength);
        const head = Math.max(resolvedLength * 0.32, 0.16);
        const headWidth = Math.max(resolvedLength * 0.18, 0.08);
        helper.setLength(resolvedLength, head, headWidth);
        helper.position.copy(origin);
      };

      const update = ({ pose, ambientOffsets, camera }) => {
        if (!pose || !pose.position) return;

        scratch.origin.copy(pose.position);
        if (ambientOffsets?.position) {
          scratch.origin.add(ambientOffsets.position);
        }

        if (birbAnchor) {
          scratch.direction.set(0, 0, -1).applyQuaternion(birbAnchor.quaternion);
          setArrow(modelForwardHelper, scratch.direction, scratch.origin, 1.35);
        }

        const cameraDirection = scratch.direction.set(0, 0, -1).applyQuaternion(camera.quaternion);
        setArrow(cameraForwardHelper, cameraDirection, camera.position, 1.15);

        if (flightController?.velocity) {
          const velocityLength = flightController.velocity.length();
          if (velocityLength > 1e-9) {
            scratch.direction.copy(flightController.velocity);
          } else {
            scratch.direction.set(0, 0, -1).applyQuaternion(flightController.quaternion);
          }
          setArrow(velocityHelper, scratch.direction, scratch.origin, Math.max(velocityLength, 0.6));
        }
      };

      return {
        update,
        dispose() {
          scene.remove(modelForwardHelper, cameraForwardHelper, velocityHelper);
        },
      };
    })();

    const headingTelemetry = (() => {
      const hasTelemetry = new URLSearchParams(window.location.search).has("headingDebug");
      if (!hasTelemetry) return null;

      const container = document.createElement("section");
      container.className = "heading-telemetry";
      container.innerHTML = `
          <h3>Heading / Velocity</h3>
          <dl>
            <dt>Heading</dt>
            <dd data-heading-value>0°</dd>
            <dt>Forward</dt>
            <dd data-forward-value>0.00, 0.00, -1.00</dd>
            <dt>Velocity</dt>
            <dd data-velocity-value>0.00, 0.00, 0.00</dd>
            <dt>Dot (fwd·vel)</dt>
            <dd data-dot-value>—</dd>
          </dl>
        `;

      document.body.appendChild(container);

      const headingValue = container.querySelector('[data-heading-value]');
      const forwardValue = container.querySelector('[data-forward-value]');
      const velocityValue = container.querySelector('[data-velocity-value]');
      const dotValue = container.querySelector('[data-dot-value]');

      const scratch = {
        forward: new THREE.Vector3(),
        velocity: new THREE.Vector3(),
      };

      let lastDot = null;
      let lastWarningTime = 0;

      const formatVec = (vec) =>
        `${vec.x.toFixed(2)}, ${vec.y.toFixed(2)}, ${vec.z.toFixed(2)}`;

      const update = (controller) => {
        if (!controller) return;

        const heading = Number.isFinite(controller.heading) ? controller.heading : 0;
        const headingDeg = ((heading * 180) / Math.PI).toFixed(1);
        headingValue.textContent = `${headingDeg}°`;

        const forward = scratch.forward.set(0, 0, -1).applyQuaternion(controller.quaternion);
        if (forward.lengthSq() > 1e-9) {
          forward.normalize();
        }
        forwardValue.textContent = formatVec(forward);

        const velocity = scratch.velocity.copy(controller.velocity);
        const speed = velocity.length();
        let dot = null;
        if (speed > 1e-6) {
          velocity.multiplyScalar(1 / speed);
          dot = forward.dot(velocity);
        }
        velocityValue.textContent = formatVec(controller.velocity);
        dotValue.textContent = Number.isFinite(dot) ? dot.toFixed(3) : "—";

        lastDot = dot;

        const now = typeof performance !== "undefined" ? performance.now() : 0;
        if (Number.isFinite(dot) && dot < 0.6 && now - lastWarningTime > 1200) {
          console.warn(
            "[headingDebug] Velocity diverged from forward direction",
            { headingDeg, forward: forward.toArray(), velocity: controller.velocity.toArray(), dot },
          );
          lastWarningTime = now;
        }
      };

      return {
        update,
        getDotProduct: () => lastDot,
        dispose: () => container.remove(),
      };
    })();

    const environmentButton = document.querySelector('[data-control="environment"]');
    const environmentToggleButton = document.querySelector(
      '[data-control="environment-toggle"]'
    );
    const environmentOrder = ENVIRONMENT_VARIANTS.map((variant) => variant.id);
    const defaultEnvironmentId = environmentOrder[0] ?? "forest";
    const defaultEnvironment =
      getEnvironmentDefinition(defaultEnvironmentId) ?? {
        id: defaultEnvironmentId,
        label: defaultEnvironmentId,
      };
    const environmentState = {
      order: environmentOrder,
      index: Math.max(0, environmentOrder.indexOf(defaultEnvironmentId)),
      id: defaultEnvironment.id,
      label: defaultEnvironment.label,
    };
    let environmentShell = null;
    let sphericalWorld = null;
    let glideTrail = null;
    let flightControllerInitialized = false;
    let cameraState = null;
    let newFlightSystem = null; // New flight system state

    // Hoisted variables to prevent ReferenceErrors
    let flightController = null;
    let flightControls = null;
    const CAMERA_MODE_SEQUENCE = ['follow', 'fpv'];
    let cameraModeIndex = 0;
    let preferredCameraMode = 'follow';
    let nestCameraReturnMode = 'follow';

    // motionQuery declaration
    const motionQuery = window.matchMedia("(prefers-reduced-motion: reduce)");

    // Stub for invalidateRendererSize to prevent crash if called early
    let invalidateRendererSize = () => { resizeState.dirty = true; };

    // Nesting system state
    let nestPointsSystem = null;
    let nestingSystem = null;
    let rocketSystem = null;
    let droneSystem = null;
    let nestToastTimeout = null;

    // Freeze state (when birb collides with drone)
    const freezeState = {
      isFrozen: false,
      freezeTimer: 0,
      freezeDuration: 5.0,
      cooldownTimer: 0,
      cooldownDuration: 2.0,
      flashPhase: 0,
      savedSpeed: null,
    };

    // Freeze UI elements
    const freezeIndicator = document.querySelector('[data-freeze-indicator]');
    const freezeProgress = document.querySelector('[data-freeze-progress]');

    function showFreezeUI(visible) {
      if (freezeIndicator) {
        freezeIndicator.classList.toggle('is-visible', visible);
        freezeIndicator.classList.toggle('is-frozen', freezeState.isFrozen);
      }
    }

    function updateFreezeUI(progress) {
      if (freezeProgress) {
        // SVG circle uses stroke-dashoffset for progress
        const dashOffset = 100 * (1 - progress);
        freezeProgress.style.strokeDashoffset = dashOffset;
      }
    }

    // birbAnchor is defined later in the script - these functions work because
    // they're closures that capture outer scope variables when called
    let birbAnchor = null; // Hoisted - will be assigned later

    function updateBirbFlashEffect(intensity) {
      if (!birbAnchor) return;
      birbAnchor.traverse((child) => {
        if (child.isMesh && child.material) {
          if (!child.userData.originalEmissive && child.material.emissive) {
            child.userData.originalEmissive = child.material.emissive.clone();
            child.userData.originalEmissiveIntensity = child.material.emissiveIntensity || 0;
          }
          if (child.material.emissive) {
            child.material.emissive.setHex(0xff4444);
            child.material.emissiveIntensity = intensity * 2.0;
          }
        }
      });
    }

    function clearBirbFlashEffect() {
      if (!birbAnchor) return;
      birbAnchor.traverse((child) => {
        if (child.isMesh && child.material && child.userData.originalEmissive) {
          child.material.emissive.copy(child.userData.originalEmissive);
          child.material.emissiveIntensity = child.userData.originalEmissiveIntensity;
        }
      });
    }

    // Note: triggerFreeze and updateFreezeState reference flightController and flightControls
    // which are defined later in the script. This works because functions are closures.

    function triggerFreeze() {
      if (freezeState.isFrozen) return;

      freezeState.isFrozen = true;
      freezeState.freezeTimer = freezeState.freezeDuration;
      freezeState.flashPhase = 0;

      // Store current speed and freeze movement
      if (flightController) {
        freezeState.savedSpeed = flightController.getSpeed?.() ?? 8;
        flightController.setSpeed?.(0);
      }
      if (flightControls) {
        flightControls.setFrozen?.(true);
      }

      showFreezeUI(true);
    }

    function updateFreezeState(delta) {
      // Update immunity cooldown
      if (freezeState.cooldownTimer > 0) {
        freezeState.cooldownTimer -= delta;
      }

      if (!freezeState.isFrozen) return;

      freezeState.freezeTimer -= delta;
      freezeState.flashPhase += delta * 10;

      // Flash effect (oscillate between 0 and 1)
      const intensity = Math.sin(freezeState.flashPhase * Math.PI) * 0.5 + 0.5;
      updateBirbFlashEffect(intensity);

      // Update UI progress
      updateFreezeUI(freezeState.freezeTimer / freezeState.freezeDuration);

      // Check if freeze is complete
      if (freezeState.freezeTimer <= 0) {
        freezeState.isFrozen = false;
        freezeState.cooldownTimer = freezeState.cooldownDuration;

        // Restore movement
        if (flightController && freezeState.savedSpeed !== null) {
          flightController.setSpeed?.(freezeState.savedSpeed);
        }
        if (flightControls) {
          flightControls.setFrozen?.(false);
        }

        showFreezeUI(false);
        clearBirbFlashEffect();
      }
    }

    // Nest UI elements
    const nestUI = document.querySelector('[data-nest-ui]');
    const nestTakeoffButton = document.querySelector('[data-nest-takeoff]');
    const nestLaunchButton = document.querySelector('[data-nest-launch]');
    const nestToast = document.querySelector('[data-nest-toast]');
    const nestIndicator = document.querySelector('[data-nest-indicator]');

    function showNestUI(visible) {
      if (nestUI) {
        nestUI.classList.toggle('is-visible', visible);
        nestUI.setAttribute('aria-hidden', !visible);
      }
    }

    function showNestIndicator(visible) {
      if (nestIndicator) {
        nestIndicator.classList.toggle('is-visible', visible);
      }
    }

    function showNestToast() {
      if (nestToast) {
        nestToast.classList.add('is-visible');
        if (nestToastTimeout) {
          clearTimeout(nestToastTimeout);
        }
        nestToastTimeout = setTimeout(() => {
          nestToast.classList.remove('is-visible');
        }, 4000);
      }
    }

    function updateLaunchButtonCooldown(isOnCooldown) {
      if (nestLaunchButton) {
        nestLaunchButton.classList.toggle('is-cooling', isOnCooldown);
        nestLaunchButton.disabled = isOnCooldown;
      }
    }

    function updateEnvironmentControls(config) {
      if (!config) return;
      const label = config.label ?? config.id;
      if (environmentButton) {
        environmentButton.textContent = `Environment: ${label}`;
        environmentButton.setAttribute(
          "aria-label",
          `Cycle environment (current: ${label})`
        );
        environmentButton.setAttribute("title", `Cycle environment • ${label}`);
      }
      if (environmentToggleButton) {
        const toggleLabel = environmentToggleButton.querySelector(
          '[data-environment-label]'
        );
        if (toggleLabel) {
          toggleLabel.textContent = `Environment: ${label}`;
        }
        environmentToggleButton.setAttribute(
          "aria-label",
          `Cycle environment (current: ${label})`
        );
        environmentToggleButton.setAttribute(
          "title",
          `Cycle environment • ${label}`
        );
      }
    }

    function applyLightingPreset(config) {
      if (!config || !config.lighting) return;
      const { ambient, key, rim, fill, glow } = config.lighting;
      if (ambient && lightingRig.ambient) {
        if (ambient.sky !== undefined) {
          lightingRig.ambient.color.setHex(ambient.sky);
        }
        if (ambient.ground !== undefined) {
          lightingRig.ambient.groundColor.setHex(ambient.ground);
        }
        if (ambient.intensity !== undefined) {
          lightingRig.ambient.intensity = ambient.intensity;
        }
      }
      if (key && lightingRig.keyLight) {
        if (key.color !== undefined) {
          lightingRig.keyLight.color.setHex(key.color);
        }
        if (key.intensity !== undefined) {
          lightingRig.keyLight.intensity = key.intensity;
        }
        if (Array.isArray(key.position)) {
          lightingRig.keyLight.position.set(...key.position);
        }
      }
      if (rim && lightingRig.rimLight) {
        if (rim.color !== undefined) {
          lightingRig.rimLight.color.setHex(rim.color);
        }
        if (rim.intensity !== undefined) {
          lightingRig.rimLight.intensity = rim.intensity;
        }
        if (Array.isArray(rim.position)) {
          lightingRig.rimLight.position.set(...rim.position);
        }
      }
      if (fill && lightingRig.fillLight) {
        if (fill.color !== undefined) {
          lightingRig.fillLight.color.setHex(fill.color);
        }
        if (fill.intensity !== undefined) {
          lightingRig.fillLight.intensity = fill.intensity;
        }
        if (Array.isArray(fill.position)) {
          lightingRig.fillLight.position.set(...fill.position);
        }
      }
      if (glow && lightingRig.glowLight) {
        if (glow.color !== undefined) {
          lightingRig.glowLight.color.setHex(glow.color);
        }
        if (glow.intensity !== undefined) {
          lightingRig.glowLight.intensity = glow.intensity;
        }
        if (glow.distance !== undefined) {
          lightingRig.glowLight.distance = glow.distance;
        }
        if (glow.decay !== undefined) {
          lightingRig.glowLight.decay = glow.decay;
        }
        if (Array.isArray(glow.position)) {
          lightingRig.glowLight.position.set(...glow.position);
        }
      }
    }

    const resetNestingSystems = () => {
      const wasNested = nestingSystem?.isNested?.() ?? false;

      if (nestingSystem) {
        try {
          nestingSystem.reset();
          nestingSystem = null;
        } catch (e) {
          console.warn("Nesting system reset error:", e);
        }
      }

      if (nestPointsSystem) {
        try {
          nestPointsSystem.dispose();
        } catch (e) {
          console.warn("Nest points dispose error:", e);
        }
        nestPointsSystem = null;
      }

      // Restore camera if we were locked to FPV for nesting
      if (wasNested && nestCameraReturnMode && cameraState) {
        setCameraMode(nestCameraReturnMode);
      }
      nestCameraReturnMode = preferredCameraMode ?? nestCameraReturnMode;
    };

    function setEnvironment(variantId) {
      const definition = getEnvironmentDefinition(variantId);
      if (!definition) return;

      // Dispose old world and nesting systems
      resetNestingSystems();

      // Reset rockets when changing environments
      if (rocketSystem) {
        try {
          rocketSystem.reset();
        } catch (e) {
          console.warn("Rocket system reset error:", e);
        }
      }

      // Hide nest UI when changing environments
      showNestUI(false);
      showNestIndicator(false);

      if (sphericalWorld) {
        try {
          sphericalWorld.dispose();
        } catch (disposeError) {
          console.warn("Spherical world dispose error:", disposeError);
        }
      }

      let nextWorld = null;
      try {
        nextWorld = createSphericalWorld(scene, {
          three: THREE,
          variant: definition.id,
          definition: definition,
        });
      } catch (envError) {
        console.warn("Spherical world creation failed:", envError);
      }

      sphericalWorld = nextWorld;
      glideTrail = null; // No glide trail on spherical world

      // Set sphere center for camera and flight controller to handle spherical up vector
      const sphereCenter = sphericalWorld ? new THREE.Vector3(0, 0, 0) : null;
      if (cameraState && typeof cameraState.setSphereCenter === 'function') {
        cameraState.setSphereCenter(sphereCenter);
      }
      if (flightController && typeof flightController.setSphereCenter === 'function') {
        flightController.setSphereCenter(sphereCenter);
      }

      if (sphericalWorld) {
        try {
          // Pass nestable positions from the environment to the nest system
          // Use sphericalWorld.root instead of scene so nests rotate with the world
          const nestablePositions = sphericalWorld.nestablePositions || [];
          nestPointsSystem = createNestPointsSystem(
            THREE,
            sphericalWorld.root,
            definition.id,
            SPHERE_RADIUS,
            nestablePositions
          );

          // Force matrix update for nest container to ensure visibility on first load
          if (nestPointsSystem && nestPointsSystem.container) {
            nestPointsSystem.container.updateMatrixWorld(true);
          }
          sphericalWorld.root.updateMatrixWorld(true);

          if (rocketSystem && typeof rocketSystem.setCollisionTargets === 'function') {
            rocketSystem.setCollisionTargets([sphericalWorld.root]);
          }

        } catch (nestError) {
          console.warn("Nest points creation failed:", nestError);
          nestPointsSystem = null;
        }
      } else {
        sphericalWorld = null;
        glideTrail = null;
        // Clear sphere center if world creation fails
        if (cameraState && typeof cameraState.setSphereCenter === 'function') {
          cameraState.setSphereCenter(null);
        }
        if (flightController && typeof flightController.setSphereCenter === 'function') {
          flightController.setSphereCenter(null);
        }
        if (rocketSystem && typeof rocketSystem.setCollisionTargets === 'function') {
          rocketSystem.setCollisionTargets([]);
        }
        nestPointsSystem = null;
        if (statusMetric) {
          statusMetric.textContent = "World failed to load. Try switching environments.";
        }
      }
      environmentState.id = definition.id;
      environmentState.label = definition.label;
      const resolvedIndex = environmentState.order.indexOf(definition.id);
      environmentState.index = resolvedIndex >= 0 ? resolvedIndex : 0;
      updateEnvironmentControls(definition);
      applyLightingPreset(definition);
      if (flightControllerInitialized) {
        updateControlMetrics();
      }
    }

    function cycleEnvironment(step = 1) {
      const { order } = environmentState;
      if (!order || order.length === 0) {
        return;
      }

      const total = order.length;
      const nextIndex = (environmentState.index + step + total) % total;
      const nextId = order[nextIndex];
      setEnvironment(nextId);
    }

    try {
      setEnvironment(defaultEnvironment.id);
    } catch (initEnvError) {
      console.warn("Initial environment setup failed:", initEnvError);
    }

    if (environmentButton) {
      environmentButton.addEventListener("click", () => {
        cycleEnvironment(1);
      });
    }

    if (environmentToggleButton) {
      environmentToggleButton.addEventListener("click", () => {
        cycleEnvironment(1);
      });
    }


    birbAnchor = new THREE.Group();
    scene.add(birbAnchor);

    // Keep the model aligned with the controller's forward vector (-Z) so the
    // beak points away from the camera. We detect the model's longest axis
    // (and which side has more reach) to infer the beak direction, then rotate
    // that inferred forward toward -Z. If the guess is ambiguous, use model
    // hints (procedural = +X, GLB = controller forward) to resolve direction.
    const modelOrientationOffset = new THREE.Quaternion();
    const targetModelForward = new THREE.Vector3(0, 0, -1);
    const proceduralForwardHint = new THREE.Vector3(1, 0, 0);
    const forwardGuess = new THREE.Vector3();
    const birbBoundsSize = new THREE.Vector3();

    const computeModelForwardGuess = (bounds, center, fallbackForward = targetModelForward) => {
      birbBoundsSize.subVectors(bounds.max, bounds.min);
      const axisSpans = [
        {
          axis: "x",
          span: birbBoundsSize.x,
          positive: bounds.max.x - center.x,
          negative: center.x - bounds.min.x,
        },
        {
          axis: "y",
          span: birbBoundsSize.y,
          positive: bounds.max.y - center.y,
          negative: center.y - bounds.min.y,
        },
        {
          axis: "z",
          span: birbBoundsSize.z,
          positive: bounds.max.z - center.z,
          negative: center.z - bounds.min.z,
        },
      ];

      // Prefer axes with the strongest forward/backward imbalance so wing span
      // doesn't override the actual beak direction.
      axisSpans.forEach((axis) => {
        if (axis.span > 0) {
          axis.bias = (axis.positive - axis.negative) / axis.span;
          axis.absBias = Math.abs(axis.bias);
        } else {
          axis.bias = 0;
          axis.absBias = 0;
        }
      });

      // Filter out Y-axis - birds face horizontally, not up/down
      const horizontalAxes = axisSpans.filter((a) => a.axis !== "y");

      // Find axis with strongest bias among horizontal axes
      const biasDominant = horizontalAxes.reduce((best, current) => {
        if (!best || current.absBias > best.absBias) {
          return current;
        }
        if (current.absBias === best.absBias && current.span > best.span) {
          return current;
        }
        return best;
      }, null);

      // Prefer bias-based detection, but when biases are too low (symmetric model),
      // default to Z-axis which is the standard forward direction in most 3D models.
      // Only use X-axis fallback for procedural models that explicitly face +X.
      let chosenAxis;
      if (biasDominant && biasDominant.absBias > 0.05) {
        // Clear asymmetry detected - use that axis
        chosenAxis = biasDominant;
      } else {
        // No clear asymmetry - prefer Z-axis (standard 3D convention) over X (wingspan)
        const zAxis = horizontalAxes.find((a) => a.axis === "z");
        const xAxis = horizontalAxes.find((a) => a.axis === "x");
        // Use Z if it has any bias at all, or if it's reasonably long compared to X
        if (zAxis && (zAxis.absBias > 0.01 || zAxis.span > xAxis.span * 0.5)) {
          chosenAxis = zAxis;
        } else {
          chosenAxis = biasDominant;
        }
      }

      if (!chosenAxis || chosenAxis.span <= 0) {
        forwardGuess.copy(fallbackForward);
        return forwardGuess;
      }

      const fallbackComponent =
        chosenAxis.axis === "x"
          ? fallbackForward.x
          : chosenAxis.axis === "y"
            ? fallbackForward.y
            : fallbackForward.z;
      const fallbackSign = fallbackComponent !== 0 ? Math.sign(fallbackComponent) : 1;
      const hasDirectionalBias = Math.abs(chosenAxis.bias) > 0.01;
      const sign = hasDirectionalBias
        ? Math.sign(chosenAxis.bias)
        : chosenAxis.positive !== chosenAxis.negative
          ? (chosenAxis.positive >= chosenAxis.negative ? 1 : -1)
          : fallbackSign;
      forwardGuess.set(
        chosenAxis.axis === "x" ? sign : 0,
        chosenAxis.axis === "y" ? sign : 0,
        chosenAxis.axis === "z" ? sign : 0
      );
      if (forwardGuess.lengthSq() === 0) {
        forwardGuess.copy(fallbackForward);
      }
      forwardGuess.normalize();
      return forwardGuess;
    };

    const positionBirbModel = (model, isGLB = false) => {
      if (!model) return;

      model.traverse((child) => {
        if (child.isMesh) {
          child.castShadow = false;
          child.receiveShadow = false;
        }
      });

      model.updateMatrixWorld(true);
      const birbBounds = new THREE.Box3().setFromObject(model);
      const birbCenter = new THREE.Vector3();
      birbBounds.getCenter(birbCenter);

      // The shipped GLB model already faces -Z (forward). No rotation needed.
      // The procedural birb faces +X and needs its forward inferred to align with -Z.
      const guessedForward = isGLB
        ? new THREE.Vector3(0, 0, -1)
        : computeModelForwardGuess(birbBounds, birbCenter);
      modelOrientationOffset.setFromUnitVectors(guessedForward, targetModelForward);
      // Re-center the bird so yaw/roll rotations pivot around its body instead
      // of an offset point in space.
      model.position.sub(birbCenter);

      birbAnchor.clear();
      birbAnchor.add(model);
      birbAnchor.scale.setScalar(0.52);
    };

    const createProceduralBirb = () => {
      const birbModel = new THREE.Group();

      const plumageMaterial = new THREE.MeshStandardMaterial({
        color: 0x6f9df2,
        metalness: 0.18,
        roughness: 0.46,
        emissive: 0x162a49,
        emissiveIntensity: 0.18,
      });

      const bodyGeometry = new THREE.SphereGeometry(0.62, 40, 28);
      const body = new THREE.Mesh(bodyGeometry, plumageMaterial);
      body.scale.set(1.46, 1.08, 1.04);
      body.position.set(-0.02, -0.02, 0);
      birbModel.add(body);

      const bellyGeometry = new THREE.SphereGeometry(0.46, 36, 24);
      const bellyMaterial = new THREE.MeshStandardMaterial({
        color: 0xf3ede0,
        metalness: 0.08,
        roughness: 0.58,
        emissive: 0x1b1a19,
        emissiveIntensity: 0.06,
      });
      const belly = new THREE.Mesh(bellyGeometry, bellyMaterial);
      belly.scale.set(1.08, 0.88, 0.86);
      belly.position.set(0.28, -0.16, 0);
      birbModel.add(belly);

      const headGeometry = new THREE.SphereGeometry(0.32, 36, 24);
      const headMaterial = plumageMaterial.clone();
      headMaterial.color = new THREE.Color(0x83b8ff);
      headMaterial.roughness = 0.4;
      headMaterial.emissiveIntensity = 0.14;
      const head = new THREE.Mesh(headGeometry, headMaterial);
      head.position.set(0.82, 0.26, 0);
      birbModel.add(head);

      const neckGeometry = new THREE.SphereGeometry(0.28, 32, 24, 0, Math.PI * 2, 0, Math.PI / 1.35);
      const neck = new THREE.Mesh(neckGeometry, bellyMaterial.clone());
      neck.scale.set(0.98, 0.82, 0.88);
      neck.rotation.z = Math.PI / 2;
      neck.position.set(0.46, 0.06, 0);
      birbModel.add(neck);

      const beakMaterial = new THREE.MeshStandardMaterial({
        color: 0xf3ad58,
        metalness: 0.18,
        roughness: 0.34,
        emissive: 0x3b1f08,
        emissiveIntensity: 0.24,
      });

      const upperBeakGeometry = new THREE.ConeGeometry(0.11, 0.4, 32);
      const upperBeak = new THREE.Mesh(upperBeakGeometry, beakMaterial);
      upperBeak.scale.set(1.05, 0.82, 1.18);
      upperBeak.rotation.set(0.14, 0, -Math.PI / 2.18);
      upperBeak.position.set(1.18, 0.2, 0.02);
      birbModel.add(upperBeak);

      const lowerBeakMaterial = beakMaterial.clone();
      lowerBeakMaterial.color = new THREE.Color(0xf09b3c);
      lowerBeakMaterial.roughness = 0.42;
      const lowerBeakGeometry = new THREE.ConeGeometry(0.095, 0.3, 30);
      const lowerBeak = new THREE.Mesh(lowerBeakGeometry, lowerBeakMaterial);
      lowerBeak.scale.set(1.02, 0.86, 1.08);
      lowerBeak.rotation.set(0.14, 0, -Math.PI / 1.95);
      lowerBeak.position.set(1.06, 0.12, -0.01);
      birbModel.add(lowerBeak);

      const eyeGeometry = new THREE.SphereGeometry(0.04, 20, 18);
      const eyeMaterial = new THREE.MeshStandardMaterial({
        color: 0x0c0f1a,
        metalness: 0.6,
        roughness: 0.18,
        emissive: 0x070a0f,
        emissiveIntensity: 0.35,
      });
      const eyeHighlightMaterial = new THREE.MeshStandardMaterial({
        color: 0xf7f6f4,
        metalness: 0.2,
        roughness: 0.18,
        emissive: 0x262626,
        emissiveIntensity: 0.2,
      });
      const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      leftEye.position.set(0.9, 0.26, 0.12);
      const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial.clone());
      rightEye.position.set(0.9, 0.26, -0.12);
      birbModel.add(leftEye);
      birbModel.add(rightEye);

      const eyeHighlightGeometry = new THREE.SphereGeometry(0.018, 16, 14);
      const leftHighlight = new THREE.Mesh(eyeHighlightGeometry, eyeHighlightMaterial);
      leftHighlight.position.set(0.93, 0.3, 0.12);
      const rightHighlight = new THREE.Mesh(eyeHighlightGeometry, eyeHighlightMaterial.clone());
      rightHighlight.position.set(0.93, 0.3, -0.12);
      birbModel.add(leftHighlight);
      birbModel.add(rightHighlight);

      const crestMaterial = plumageMaterial.clone();
      crestMaterial.color = new THREE.Color(0x91c7ff);
      crestMaterial.roughness = 0.38;
      crestMaterial.metalness = 0.12;
      crestMaterial.emissive = new THREE.Color(0x1d334f);
      crestMaterial.emissiveIntensity = 0.18;
      const crestGeometry = new THREE.ConeGeometry(0.1, 0.42, 18);
      crestGeometry.translate(0, 0.21, 0);
      const crest = new THREE.Mesh(crestGeometry, crestMaterial);
      crest.rotation.set(0, 0, -Math.PI / 2.1);
      crest.position.set(0.64, 0.34, 0);
      crest.scale.set(0.84, 1, 0.84);
      birbModel.add(crest);

      const wingMaterial = plumageMaterial.clone();
      wingMaterial.roughness = 0.35;
      wingMaterial.metalness = 0.22;
      wingMaterial.emissive = new THREE.Color(0x1a2d4c);
      wingMaterial.emissiveIntensity = 0.22;
      const wingGeometry = new THREE.CapsuleGeometry(0.26, 0.8, 16, 24);
      wingGeometry.rotateZ(Math.PI / 2);
      wingGeometry.translate(0, 0, 0);

      const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
      leftWing.name = 'leftWing';
      leftWing.position.set(-0.18, 0.1, 0.64);
      leftWing.rotation.set(Math.PI / 2.2, -Math.PI / 4, Math.PI / 2.6);
      leftWing.scale.set(1.06, 1.06, 1.1);
      leftWing.userData.baseRotation = leftWing.rotation.clone();
      birbModel.add(leftWing);

      const rightWing = new THREE.Mesh(wingGeometry, wingMaterial.clone());
      rightWing.name = 'rightWing';
      rightWing.position.set(-0.18, 0.1, -0.64);
      rightWing.rotation.set(Math.PI / 2.2, Math.PI / 4, Math.PI / 2.6);
      rightWing.scale.set(1.06, 1.06, 1.1);
      rightWing.userData.baseRotation = rightWing.rotation.clone();
      birbModel.add(rightWing);

      const tailMaterial = plumageMaterial.clone();
      tailMaterial.color = new THREE.Color(0x5f8fd6);
      tailMaterial.roughness = 0.42;
      tailMaterial.emissive = new THREE.Color(0x13243d);
      tailMaterial.emissiveIntensity = 0.2;
      const tailFeatherMaterial = plumageMaterial.clone();
      tailFeatherMaterial.color = new THREE.Color(0x6ea6f7);
      tailFeatherMaterial.roughness = 0.4;
      tailFeatherMaterial.emissive = new THREE.Color(0x162d4f);
      tailFeatherMaterial.emissiveIntensity = 0.18;

      const tailBaseGeometry = new THREE.ConeGeometry(0.32, 0.72, 20);
      tailBaseGeometry.rotateZ(Math.PI / 2);
      const tailBase = new THREE.Mesh(tailBaseGeometry, tailMaterial);
      tailBase.position.set(-0.38, -0.16, 0);
      tailBase.rotation.set(0.12, 0, Math.PI / 20);
      tailBase.scale.set(1.08, 1, 0.92);

      const tailFanGeometry = new THREE.ConeGeometry(0.34, 0.94, 18);
      tailFanGeometry.rotateZ(Math.PI / 2);
      const tailFan = new THREE.Mesh(tailFanGeometry, tailFeatherMaterial);
      tailFan.position.set(-0.8, -0.16, 0);
      tailFan.rotation.set(0.22, 0, Math.PI / 10);
      tailFan.scale.set(1.2, 1.08, 1);

      const tailGroup = new THREE.Group();
      tailGroup.add(tailBase);
      tailGroup.add(tailFan);
      birbModel.add(tailGroup);

      const legMaterial = new THREE.MeshStandardMaterial({
        color: 0xd8995f,
        metalness: 0.2,
        roughness: 0.36,
        emissive: 0x201204,
        emissiveIntensity: 0.24,
      });

      const legGeometry = new THREE.CylinderGeometry(0.04, 0.055, 0.42, 14);
      const ankleGeometry = new THREE.SphereGeometry(0.07, 16, 12);
      const footPadGeometry = new THREE.SphereGeometry(0.14, 22, 18);
      const toeGeometry = new THREE.CapsuleGeometry(0.03, 0.24, 8, 16);
      const backToeGeometry = new THREE.CapsuleGeometry(0.026, 0.16, 6, 14);
      const clawGeometry = new THREE.ConeGeometry(0.02, 0.08, 14);

      const toeMaterial = new THREE.MeshStandardMaterial({
        color: 0xe1ab73,
        metalness: 0.22,
        roughness: 0.4,
        emissive: 0x29180a,
        emissiveIntensity: 0.26,
      });
      const clawMaterial = new THREE.MeshStandardMaterial({
        color: 0x2d2a28,
        metalness: 0.35,
        roughness: 0.3,
        emissive: 0x0d0c0b,
        emissiveIntensity: 0.24,
      });

      const createFoot = (side = 1) => {
        const footGroup = new THREE.Group();

        const leg = new THREE.Mesh(legGeometry, legMaterial);
        leg.rotation.set(0.12, side * -0.08, Math.PI / 2.24);
        leg.position.set(0.02, -0.2, side * -0.02);
        footGroup.add(leg);

        const ankle = new THREE.Mesh(ankleGeometry, legMaterial.clone());
        ankle.scale.set(1.15, 0.82, 1.15);
        ankle.position.set(0.18, -0.36, side * -0.02);
        footGroup.add(ankle);

        const pad = new THREE.Mesh(footPadGeometry, legMaterial.clone());
        pad.scale.set(1.8, 0.42, 1.36);
        pad.position.set(0.3, -0.42, side * -0.02);
        footGroup.add(pad);

        const toeLayout = [
          { angle: 0.34, z: 0.16, length: 1.08 },
          { angle: 0.08, z: 0, length: 1.18 },
          { angle: -0.28, z: -0.16, length: 1 },
        ];

        toeLayout.forEach(({ angle, z, length }) => {
          const toeGroup = new THREE.Group();
          toeGroup.rotation.y = angle * side;
          toeGroup.position.set(0.38, -0.46, side * (z - 0.02));

          const toe = new THREE.Mesh(toeGeometry, toeMaterial);
          toe.scale.set(1, length, 1);
          toe.rotation.set(Math.PI / 7, 0, Math.PI / 2);
          toeGroup.add(toe);

          const claw = new THREE.Mesh(clawGeometry, clawMaterial);
          claw.rotation.set(Math.PI / 2.6, 0, -Math.PI / 2);
          claw.position.set(0.18 * length + 0.04, -0.02, 0);
          toeGroup.add(claw);

          footGroup.add(toeGroup);
        });

        const backToe = new THREE.Mesh(backToeGeometry, toeMaterial);
        backToe.rotation.set(-Math.PI / 2.1, 0, Math.PI / 2);
        backToe.position.set(0.14, -0.42, side * -0.12);
        footGroup.add(backToe);

        const backClaw = new THREE.Mesh(clawGeometry, clawMaterial.clone());
        backClaw.scale.set(0.9, 0.82, 0.9);
        backClaw.rotation.set(-Math.PI / 2.4, 0, -Math.PI / 2);
        backClaw.position.set(0.02, -0.4, side * -0.12);
        footGroup.add(backClaw);

        return footGroup;
      };

      const leftFoot = createFoot(1);
      leftFoot.position.set(0.26, -0.54, 0.34);
      leftFoot.rotation.set(0.02, 0.08, -0.04);
      birbModel.add(leftFoot);

      const rightFoot = createFoot(-1);
      rightFoot.position.set(0.26, -0.54, -0.34);
      rightFoot.rotation.set(0.02, -0.08, 0.04);
      birbModel.add(rightFoot);

      return birbModel;
    };

    positionBirbModel(createProceduralBirb());

    if (GLTFLoader) {
      const gltfLoader = new GLTFLoader();
      gltfLoader.load(
        "./birb.glb",
        (gltf) => {
          const model = gltf.scene || gltf.scenes?.[0];
          if (!model) return;
          positionBirbModel(model, true);  // GLB model faces -Z
        },
        undefined,
        (error) => {
          console.warn("Failed to load birb GLB; using procedural model", error);
        }
      );
    }

    const motionState = {
      animate: !motionQuery.matches,
      elapsed: 0,
    };

    const fpsState = {
      lastSampleTime: null,
      frames: 0,
      value: 0,
    };

    let previousTime = null;

    const toggleButton = document.querySelector('[data-control="toggle"]');
    const resetButton = document.querySelector('[data-control="reset"]');
    const fullscreenToggleButton = document.querySelector('[data-control="fullscreen"]');
    const glideSpeedInput = document.querySelector("#glide-speed");
    const glideSpeedDisplay = document.querySelector('[data-display="glide-speed"]');
    const invertPitchCheckbox = document.querySelector('[data-control="invert-pitch"]');
    const speedMetric = document.querySelector('[data-metric="speed"]');
    const throttleMetric = document.querySelector('[data-metric="throttle"]');
    const fpsMetric = document.querySelector('[data-metric="fps"]');
    const fullscreenToggleLabel = fullscreenToggleButton
      ? fullscreenToggleButton.querySelector('[data-fullscreen-label]')
      : null;
    const fullscreenEnterIcon = fullscreenToggleButton
      ? fullscreenToggleButton.querySelector('[data-icon="enter"]')
      : null;
    const fullscreenExitIcon = fullscreenToggleButton
      ? fullscreenToggleButton.querySelector('[data-icon="exit"]')
      : null;

    const initialThrottle = clampThrottle(Number.parseFloat(glideSpeedInput?.value ?? ""), 0);

    // Load invert pitch preference from localStorage
    const INVERT_PITCH_STORAGE_KEY = 'birbFlightInvertPitch';
    const savedInvertPitch = localStorage.getItem(INVERT_PITCH_STORAGE_KEY) === 'true';
    if (invertPitchCheckbox) {
      invertPitchCheckbox.checked = savedInvertPitch;
    }

    const controlState = {
      manuallyPaused: false,
      systemPaused: motionQuery.matches,
    };

    const fullscreenState = {
      active: false,
      useNative: false,
    };

    function updateFpsReadout(time) {
      if (!fpsMetric) return;

      if (fpsState.lastSampleTime === null) {
        fpsState.lastSampleTime = time;
        fpsState.frames = 0;
        return;
      }

      fpsState.frames += 1;
      const elapsed = time - fpsState.lastSampleTime;
      if (elapsed < 250) {
        return;
      }

      const fps = (fpsState.frames / elapsed) * 1000;
      fpsState.value = fps;
      fpsState.frames = 0;
      fpsState.lastSampleTime = time;
      const formatted = Math.max(0, Math.round(fps)).toString().padStart(2, "0");
      fpsMetric.textContent = formatted;
    }

    function updateControlMetrics(speed) {
      const throttleSetting = Number.isFinite(flightController?.throttle)
        ? flightController.throttle
        : 0;
      const throttlePercent = Math.round(throttleSetting * 100);
      const resolvedSpeed = Number.isFinite(speed)
        ? speed
        : typeof flightController?.getSpeed === "function"
          ? flightController.getSpeed()
          : flightController?.speed;
      const safeSpeed = Number.isFinite(resolvedSpeed) ? resolvedSpeed : 0;
      if (speedMetric) {
        speedMetric.textContent = `${safeSpeed.toFixed(2)}u/s`;
      }
      if (throttleMetric) {
        throttleMetric.textContent = `${throttlePercent}%`;
      }
      if (statusMetric) {
        if (contextState.lost) {
          statusMetric.textContent = "Rendering paused while recovering graphics context...";
        } else if (controlState.systemPaused) {
          statusMetric.textContent = "Motion paused via system preference";
        } else if (!motionState.animate) {
          statusMetric.textContent = "Flight paused";
        } else if (flightController.isSprinting) {
          statusMetric.textContent = "Speed boost engaged";
        } else if (safeSpeed < 0.25) {
          statusMetric.textContent = "Hovering in place. Push the left stick forward to cruise.";
        } else {
          const environmentMessage = environmentState.label
            ? `the ${environmentState.label} environment`
            : "this environment";
          statusMetric.textContent = `Exploring ${environmentMessage}. (Press V to change view)`;
        }
      }
    }

    function updateToggleButton() {
      if (!toggleButton) return;
      if (controlState.systemPaused) {
        toggleButton.disabled = true;
        toggleButton.setAttribute("aria-pressed", "false");
        toggleButton.textContent = "Motion Disabled";
      } else {
        toggleButton.disabled = false;
        toggleButton.textContent = motionState.animate ? "Pause Flight" : "Resume Flight";
        toggleButton.setAttribute("aria-pressed", motionState.animate ? "true" : "false");
      }
    }

    function refreshAnimationState() {
      motionState.animate = !(controlState.manuallyPaused || controlState.systemPaused);
      if (!motionState.animate) {
        previousTime = null;
      }
      updateToggleButton();
      updateControlMetrics();
    }

    function toggleManualPause() {
      if (controlState.systemPaused) return;
      controlState.manuallyPaused = !controlState.manuallyPaused;
      refreshAnimationState();
    }

    if (toggleButton) {
      toggleButton.addEventListener("click", () => {
        toggleManualPause();
      });
    }

    /* Simplified fullscreen - uses CSS fixed positioning on mobile, native API on desktop */
    const isTouchDevice = window.matchMedia("(pointer: coarse)").matches;

    function getFullscreenElement() {
      return document.fullscreenElement || document.webkitFullscreenElement || null;
    }

    function isFullscreenActive() {
      return fullscreenState.active || getFullscreenElement() != null;
    }

    function applyFullscreen(active) {
      fullscreenState.active = active;
      if (canvasWrapper) {
        canvasWrapper.classList.toggle("is-fullscreen", active);
      }
      if (document.body) {
        document.body.classList.toggle("is-fullscreen", active);
      }
      syncFullscreenUi();
      // Trigger resize to update renderer
      scheduleRendererResize(true);
    }

    function syncFullscreenUi() {
      if (!fullscreenToggleButton) return;
      const active = isFullscreenActive();
      const labelText = active ? "Exit Fullscreen" : "Enter Fullscreen";
      fullscreenToggleButton.setAttribute("aria-pressed", String(active));
      fullscreenToggleButton.setAttribute("aria-label", labelText);
      if (fullscreenToggleLabel) {
        fullscreenToggleLabel.textContent = labelText;
      }
      if (fullscreenEnterIcon && fullscreenExitIcon) {
        fullscreenEnterIcon.toggleAttribute("hidden", active);
        fullscreenExitIcon.toggleAttribute("hidden", !active);
      }
    }

    function enterFullscreen() {
      if (isFullscreenActive()) return;

      // On touch devices, use CSS-based fullscreen (more reliable)
      if (isTouchDevice) {
        applyFullscreen(true);
        return;
      }

      // On desktop, try native fullscreen first
      const el = canvasWrapper || document.documentElement;
      const request = el.requestFullscreen || el.webkitRequestFullscreen;
      if (request) {
        Promise.resolve(request.call(el))
          .then(() => {
            fullscreenState.useNative = true;
            syncFullscreenUi();
          })
          .catch(() => {
            // Fallback to CSS fullscreen
            applyFullscreen(true);
          });
      } else {
        applyFullscreen(true);
      }
    }

    function exitFullscreen() {
      // Exit native fullscreen if active
      const fsEl = getFullscreenElement();
      if (fsEl) {
        const exit = document.exitFullscreen || document.webkitExitFullscreen;
        if (exit) {
          Promise.resolve(exit.call(document)).catch(() => { });
        }
        fullscreenState.useNative = false;
      }
      // Always clear CSS fullscreen state
      applyFullscreen(false);
    }

    function toggleFullscreen() {
      if (isFullscreenActive()) {
        exitFullscreen();
      } else {
        enterFullscreen();
      }
    }

    // Listen for native fullscreen changes (e.g., user presses Escape)
    document.addEventListener("fullscreenchange", () => {
      if (!getFullscreenElement() && fullscreenState.useNative) {
        fullscreenState.useNative = false;
        applyFullscreen(false);
      }
      syncFullscreenUi();
    });
    document.addEventListener("webkitfullscreenchange", () => {
      if (!getFullscreenElement() && fullscreenState.useNative) {
        fullscreenState.useNative = false;
        applyFullscreen(false);
      }
      syncFullscreenUi();
    });

    if (fullscreenToggleButton) {
      fullscreenToggleButton.addEventListener("click", toggleFullscreen);
    }

    syncFullscreenUi();

    function clampThrottle(value, fallback = 0) {
      if (!Number.isFinite(value)) {
        return fallback;
      }
      return Math.min(Math.max(value, 0), 1);
    }

    function updateGlideSpeedDisplay(value = flightController?.throttle) {
      if (!glideSpeedDisplay) return;
      const throttleSetting = Number.isFinite(value) ? value : flightController?.throttle;
      const throttlePercent = Math.round(clampThrottle(throttleSetting ?? 0) * 100);
      glideSpeedDisplay.textContent = `${throttlePercent}%`;
    }

    motionQuery.addEventListener("change", (event) => {
      controlState.systemPaused = event.matches;
      refreshAnimationState();
    });

    function updateRendererSize(force = false) {
      if (!resizeState.dirty && !force) {
        return;
      }

      const clientWidth = canvas.clientWidth || window.innerWidth;
      const clientHeight = canvas.clientHeight || window.innerHeight;

      if (!clientWidth || !clientHeight) return;

      const nextWidth = Math.floor(clientWidth);
      const nextHeight = Math.floor(clientHeight);
      const pixelRatio = Math.min(window.devicePixelRatio || 1, DPR_CAP);

      if (
        !force &&
        resizeState.width === nextWidth &&
        resizeState.height === nextHeight &&
        resizeState.pixelRatio === pixelRatio
      ) {
        resizeState.dirty = false;
        return;
      }

      resizeState.width = nextWidth;
      resizeState.height = nextHeight;
      resizeState.pixelRatio = pixelRatio;
      resizeState.dirty = false;

      renderer.setPixelRatio(pixelRatio);
      renderer.setSize(nextWidth, nextHeight, false);
      if (cameraState) {
        const camera = cameraState.camera;
        camera.aspect = nextWidth / nextHeight;
        camera.updateProjectionMatrix();
      }
    }

    let resizeRafId = null;
    let resizeForce = false;
    const scheduleRendererResize = (force = false) => {
      invalidateRendererSize();
      resizeForce = resizeForce || force;
      if (typeof requestAnimationFrame !== "function") {
        const shouldForce = resizeForce;
        resizeForce = false;
        updateRendererSize(shouldForce);
        return;
      }
      if (resizeRafId !== null) {
        return;
      }
      resizeRafId = requestAnimationFrame(() => {
        resizeRafId = null;
        const shouldForce = resizeForce;
        resizeForce = false;
        updateRendererSize(shouldForce);
      });
    };

    const resizeObserver =
      typeof ResizeObserver !== "undefined"
        ? new ResizeObserver(() => {
          scheduleRendererResize();
        })
        : null;
    if (resizeObserver) {
      resizeObserver.observe(canvas);
    }
    window.addEventListener(
      "orientationchange",
      () => {
        scheduleRendererResize(true);
      },
      {
        passive: true,
      }
    );
    window.addEventListener(
      "resize",
      () => {
        scheduleRendererResize();
      },
      { passive: true }
    );

    // Start bird on top of spherical world (sphere radius + some height)
    const birdStartHeight = SPHERE_RADIUS + 3;

    // FLIGHT PORT: Always use New Flight System (BirdFlight + BirdVisual + BirdCamera)
    console.log('🚀 Initializing Flight System');

    // 1. Input
    // Touch input uses createTouchInput (nipplejs) which feeds into flight.tick()
    // createFlightControls does NOT get nipplejs to avoid duplicate managers
    const touchZone = document.querySelector('[data-touch-zone]');
    const touchInput = touchZone && nipplejs ? createTouchInput(touchZone, nipplejs) : null;
    // Hide the static HTML thumbstick element when using dynamic nipplejs joystick
    if (touchInput && touchZone) {
      touchZone.classList.add('has-dynamic-joystick');
    }
    const keyboardInput = createKeyboardInput();
    const flightInput = touchInput ? combineInputs(touchInput, keyboardInput) : keyboardInput;

    // 2. Flight Physics (BirdFlight)
    const flight = new BirdFlight(THREE, {
      sphereCenter: new THREE.Vector3(0, 0, 0),
      sphereRadius: SPHERE_RADIUS,
      speed: 4,
      position: new THREE.Vector3(0, birdStartHeight, 0)
    });

    // 3. Visuals
    const visual = new BirdVisual(THREE, {
      maxBankAngle: Math.PI * 0.35,
      maxPitchTilt: Math.PI * 0.2,
    });

    const aimRig = new AimRig(THREE);

    // LEGACY COMPATIBILITY: Map `flightController` to `flight` (BirdFlight)
    flightController = flight;
    flightControllerInitialized = true;

    // Set sphere center on flight controller for spherical world support
    if (sphericalWorld && typeof flightController.setSphereCenter === 'function') {
      flightController.setSphereCenter(new THREE.Vector3(0, 0, 0));
    }

    // Initialize Camera State (Legacy camera rig system)
    cameraState = createCameraState({
      three: THREE,
      scene,
      flightController,
    });

    if (sphericalWorld && typeof cameraState.setSphereCenter === 'function') {
      cameraState.setSphereCenter(new THREE.Vector3(0, 0, 0));
    }

    // 4. Camera (BirdCamera - simpler, tighter follow)
    // Use the camera created by cameraState
    const bCam = new BirdCamera(THREE, cameraState.camera, {
      distance: 5,
      height: 2,
      lookAhead: 2,
      smoothing: 0.1,
      sphereCenter: new THREE.Vector3(0, 0, 0),
    });

    // 5. System Container
    newFlightSystem = {
      input: flightInput,
      flight: flight,
      visual: visual,
      camera: bCam
    };

    const syncAvatarVisibility = (mode) => {
      if (!birbAnchor) return;
      birbAnchor.visible = mode !== CAMERA_MODES.FPV;
    };

    const setCameraMode = (mode, { forced = false } = {}) => {
      if (!cameraState) return;
      cameraState.setMode(mode);
      const index = CAMERA_MODE_SEQUENCE.indexOf(mode);
      if (index !== -1) {
        cameraModeIndex = index;
        if (!forced) {
          preferredCameraMode = CAMERA_MODE_SEQUENCE[index];
          nestCameraReturnMode = preferredCameraMode;
        }
      }
      syncAvatarVisibility(mode);
      updateControlMetrics();
    };

    const cycleCameraMode = () => {
      if (nestingSystem?.isNested?.()) {
        return;
      }
      const nextIndex = (cameraModeIndex + 1) % CAMERA_MODE_SEQUENCE.length;
      setCameraMode(CAMERA_MODE_SEQUENCE[nextIndex]);
    };

    setCameraMode(CAMERA_MODE_SEQUENCE[cameraModeIndex]);

    const blendedQuaternion = new THREE.Quaternion();
    const worldUp = new THREE.Vector3(0, 1, 0);
    const sphericalWorldAlignment = {
      birdDir: new THREE.Vector3(),
      forward: new THREE.Vector3(),
      projectedForward: new THREE.Vector3(),
      right: new THREE.Vector3(),
      alignedForward: new THREE.Vector3(),
      targetQuat: new THREE.Quaternion(),
      basisMatrix: new THREE.Matrix4(),
    };
    const sphericalCollisionFrame = {
      worldRotation: new THREE.Quaternion(),
      inverseRotation: new THREE.Quaternion(),
      localPosition: new THREE.Vector3(),
      localVelocity: new THREE.Vector3(),
      resolvedPosition: new THREE.Vector3(),
      resolvedVelocity: new THREE.Vector3(),
    };

    // NOTE: nipplejs is NOT passed here - touch input is handled by createTouchInput
    // above, which feeds into flight.tick(). This avoids duplicate nipplejs managers.
    flightControls = createFlightControls({
      canvas,
      flightController,
      leftThumbstickElement: document.querySelector('[data-thumbstick="left"]'),
      rightThumbstickElement: document.querySelector('[data-thumbstick="right"]'),
      touchZoneElement: document.querySelector('[data-touch-zone]'),
      // nipplejs intentionally omitted - touch handled by createTouchInput
      getCameraMode: () => cameraState?.getMode?.(),
      followMode: CAMERA_MODES.FOLLOW,
      onThrustChange: () => updateControlMetrics(),
      invertPitch: savedInvertPitch,
    });

    const applyInvertPitchPreference = (isInverted, { persist = true, updateUi = false } = {}) => {
      const inverted = Boolean(isInverted);
      flightController?.setInvertPitch?.(inverted);
      flightControls?.setInvertPitch?.(inverted);
      if (persist) {
        localStorage.setItem(INVERT_PITCH_STORAGE_KEY, inverted ? 'true' : 'false');
      }
      if (updateUi && invertPitchCheckbox) {
        invertPitchCheckbox.checked = inverted;
      }
    };

    applyInvertPitchPreference(savedInvertPitch, { persist: false });

    // Initialize rocket system with explosion sound callback
    rocketSystem = createRocketSystem(THREE, scene, {
      onExplosion: () => {
        playExplosionSound();
      },
    });

    // Set collision targets for rocket system if environment already loaded
    // (This handles the case where the default environment is set before rocketSystem is created)
    if (sphericalWorld && sphericalWorld.root) {
      rocketSystem.setCollisionTargets([sphericalWorld.root]);
    }

    // Initialize drone target system
    droneSystem = createDroneSystem(THREE, scene, {
      onDroneDestroyed: (position) => {
        // Create explosion visual at drone position
        if (rocketSystem && rocketSystem.createExplosionAt) {
          rocketSystem.createExplosionAt(position);
        }
        playExplosionSound();
      },
    });

    // Initialize nesting system with state change callback
    const handleNestingStateChange = (newState, previousState, currentNest) => {
      const isNested = newState === NESTING_STATES.NESTED;
      const isApproaching = newState === NESTING_STATES.APPROACHING;
      const isLeavingNest = previousState === NESTING_STATES.NESTED && newState !== NESTING_STATES.NESTED;

      // Show/hide nest mode UI
      showNestUI(isNested);

      // Hide the entire canvas-actions container while nested
      // This hides the environment and fullscreen toggle buttons
      if (canvasActions) {
        canvasActions.hidden = isNested;
      }

      // Show/hide proximity indicator
      showNestIndicator(isApproaching && !isNested);

      // Show welcome toast on landing
      if (isNested && previousState === NESTING_STATES.LANDING) {
        showNestToast();
      }

      // Lock camera to FPV while nested for aiming
      if (isNested) {
        nestCameraReturnMode = cameraState?.getMode?.() ?? preferredCameraMode;
        setCameraMode(CAMERA_MODES.FPV, { forced: true });
      } else if (isLeavingNest && nestCameraReturnMode) {
        setCameraMode(nestCameraReturnMode);
      }

      // Enable/disable nest look mode for free camera look-around
      if (typeof flightController.setNestLookMode === 'function') {
        flightController.setNestLookMode(isNested);
      }
      if (aimRig) {
        if (isNested) {
          aimRig.setReferenceFromQuaternion(flightController.quaternion);
          aimRig.setActive(true);
        } else {
          aimRig.setActive(false);
        }
      }

      // Update status message
      if (statusMetric) {
        if (isNested) {
          statusMetric.textContent = "Nested! Look around with the joystick. Launch rockets or take off.";
        } else if (isApproaching) {
          statusMetric.textContent = "Nest nearby! Tap the screen or click to land.";
        }
      }
    };

    // Create nesting system (will be updated when nestPointsSystem exists)
    const initNestingSystem = () => {
      if (nestPointsSystem && !nestingSystem) {
        nestingSystem = createNestingSystem(THREE, {
          flightController,
          nestPointsSystem,
          aimRig,
          onStateChange: handleNestingStateChange,
        });
      }
    };

    // Nest UI button handlers
    if (nestTakeoffButton) {
      nestTakeoffButton.addEventListener('click', () => {
        if (nestingSystem) {
          nestingSystem.takeOff();
        }
      });
      nestTakeoffButton.addEventListener('touchend', (e) => {
        e.preventDefault();
        if (nestingSystem) {
          nestingSystem.takeOff();
        }
      });
    }

    if (nestLaunchButton) {
      let lastTouchLaunchAt = 0;

      // CRITICAL: Unlock audio on touchstart - mobile browsers require this
      // touchend is too late for iOS Safari and other mobile browsers
      nestLaunchButton.addEventListener('touchstart', () => {
        unlockAudio();
        handleLaunch();
        lastTouchLaunchAt = Date.now();
      }, { passive: true });

      // Synchronous launch handler (data3-cisco-live pattern)
      // Keep everything in the gesture call stack for iOS audio to work
      const handleLaunch = () => {
        // CRITICAL: Initialize audio synchronously within gesture context
        // This unlocks audio AND pre-generates buffers for instant playback
        unlockAudio();

        if (nestingSystem && nestingSystem.isNested() && rocketSystem && rocketSystem.canFire()) {
          const launchDirection = nestingSystem.getLookDirection();
          const launchPosition = flightController.position.clone().addScaledVector(launchDirection, 1.0);
          const fired = rocketSystem.fire(launchPosition, launchDirection);
          if (fired) {
            // Play sound synchronously using pre-generated buffer
            playRocketFireSound();
            updateLaunchButtonCooldown(true);
          }
        }
      };

      nestLaunchButton.addEventListener('click', () => {
        if (Date.now() - lastTouchLaunchAt < 600) {
          return;
        }
        handleLaunch();
      });
      nestLaunchButton.addEventListener('touchend', (e) => {
        e.preventDefault();
      });
    }

    // Nest indicator button handler (for landing when approaching)
    if (nestIndicator) {
      const handleLand = () => {
        if (nestingSystem && nestingSystem.getState() === NESTING_STATES.APPROACHING) {
          nestingSystem.tryLandOnNest(flightController.position);
        }
      };

      nestIndicator.addEventListener('click', handleLand);
      nestIndicator.addEventListener('touchend', (e) => {
        e.preventDefault();
        handleLand();
      });
    }

    // Handle canvas click/tap for landing on nests
    canvas.addEventListener('click', (event) => {
      if (nestingSystem && nestingSystem.getState() === NESTING_STATES.APPROACHING) {
        nestingSystem.tryLandOnNest(flightController.position);
      }
    });

    // Tap detection on touch zone for mobile landing
    // (touch zone captures all touches, so canvas click doesn't fire on mobile)
    if (touchZone) {
      let tapStartTime = 0;
      let tapStartX = 0;
      let tapStartY = 0;
      const TAP_MAX_DURATION = 250; // ms
      const TAP_MAX_DISTANCE = 15; // px

      touchZone.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1) {
          tapStartTime = Date.now();
          tapStartX = e.touches[0].clientX;
          tapStartY = e.touches[0].clientY;
        }
      }, { passive: true });

      touchZone.addEventListener('touchend', (e) => {
        const tapDuration = Date.now() - tapStartTime;
        if (tapDuration > TAP_MAX_DURATION) return;

        // Check distance moved
        const touch = e.changedTouches[0];
        if (!touch) return;
        const dx = touch.clientX - tapStartX;
        const dy = touch.clientY - tapStartY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance > TAP_MAX_DISTANCE) return;

        // This was a tap - try to land if approaching a nest
        if (nestingSystem && nestingSystem.getState() === NESTING_STATES.APPROACHING) {
          nestingSystem.tryLandOnNest(flightController.position);
        }
      }, { passive: true });
    }

    const applyThrottleFromInput = () => {
      if (!glideSpeedInput) return;
      const value = clampThrottle(Number.parseFloat(glideSpeedInput.value));
      flightController.setThrottle(value);
      updateGlideSpeedDisplay(flightController.throttle);
      updateControlMetrics();
    };

    if (glideSpeedInput) {
      updateGlideSpeedDisplay();
      glideSpeedInput.value = `${flightController.throttle}`;
      glideSpeedInput.addEventListener("input", applyThrottleFromInput);
      glideSpeedInput.addEventListener("change", applyThrottleFromInput);
    } else {
      updateGlideSpeedDisplay();
    }

    if (invertPitchCheckbox) {
      invertPitchCheckbox.addEventListener("change", () => {
        const isInverted = invertPitchCheckbox.checked;
        applyInvertPitchPreference(isInverted);
      });
    }

    if (resetButton) {
      resetButton.addEventListener("click", () => {
        flightController.reset();
        cameraState.reset();
        const restoredMode = preferredCameraMode ?? CAMERA_MODE_SEQUENCE[0];
        setCameraMode(restoredMode);
        flightControls.reset({ releasePointerLock: true });
        applyInvertPitchPreference(invertPitchCheckbox?.checked ?? savedInvertPitch, {
          persist: false,
          updateUi: true,
        });
        // Reset nesting state
        if (nestingSystem) {
          nestingSystem.reset();
        }
        if (rocketSystem) {
          rocketSystem.reset();
        }
        if (aimRig) {
          aimRig.setActive(false);
        }
        showNestUI(false);
        showNestIndicator(false);
        updateControlMetrics();
      });
    }

    document.addEventListener("keydown", (event) => {
      const { code } = event;
      if (
        event.target &&
        (event.target.isContentEditable || /^(INPUT|TEXTAREA|SELECT)$/i.test(event.target.tagName))
      ) {
        return;
      }
      if (code === "KeyV" && !event.repeat) {
        cycleCameraMode();
        event.preventDefault();
      }
    });

    window.addEventListener("blur", () => {
      flightControls.reset({ releasePointerLock: true });
    });

    const renderFrame = (time = 0) => {
      if (contextState.lost) {
        return;
      }
      let delta = 0;
      if (motionState.animate) {
        if (previousTime === null) {
          previousTime = time;
        }
        delta = (time - previousTime) * 0.001;
        motionState.elapsed += delta;
        previousTime = time;
      } else {
        previousTime = null;
      }

      const lookDeltaTime = Math.min(delta > 0 ? delta : 1 / 60, 0.05);

      // Initialize nesting system if needed (after environment change)
      if (nestPointsSystem && !nestingSystem) {
        initNestingSystem();
      }

      // Update nesting system and check if we should apply flight controls
      let isNested = false;
      if (nestingSystem) {
        nestingSystem.update(delta, flightController.position);
        isNested = nestingSystem.isNested();
      }

      let nestedAimQuaternion = null;

      // Get input state early (needed for both flight and aim rig when nested)
      const inputState = newFlightSystem?.input?.get() ?? { x: 0, y: 0, active: false };

      if (isNested && aimRig?.isActive?.()) {
        // When nested, use the touch/keyboard input for look-around
        // flightControls.getAnalogLookState() doesn't work because nipplejs isn't passed to it
        const pointerDelta = flightControls.consumePointerLookDelta?.() ?? { x: 0, y: 0 };
        aimRig.update(
          {
            axisX: inputState.x,
            axisY: inputState.y,
            deltaX: pointerDelta.x,
            deltaY: pointerDelta.y,
          },
          lookDeltaTime
        );
        nestedAimQuaternion = aimRig.getQuaternion();
      } else {
        // Apply look controls during flight
        flightControls.applyAnalogLook(lookDeltaTime);
      }

      // Update rockets
      if (rocketSystem) {
        rocketSystem.update(delta);
        // Update cooldown button state
        if (!rocketSystem.canFire()) {
          updateLaunchButtonCooldown(true);
        } else {
          updateLaunchButtonCooldown(false);
        }

        // Check rocket-drone collisions
        if (droneSystem) {
          const rockets = rocketSystem.getRockets();
          for (let i = rockets.length - 1; i >= 0; i--) {
            const rocket = rockets[i];
            const droneHit = droneSystem.checkRocketCollision(rocket.position);
            if (droneHit.hit) {
              droneSystem.destroyDrone(droneHit.index);
              rocketSystem.removeRocket(i);
            }
          }
        }
      }

      // Update drones
      if (droneSystem) {
        droneSystem.update(delta);

        // Check birb-drone collisions (only when flying, not nested, not frozen)
        if (flightController && !isNested && !freezeState.isFrozen && freezeState.cooldownTimer <= 0) {
          const birbHit = droneSystem.checkBirbCollision(flightController.position);
          if (birbHit.hit) {
            triggerFreeze();
            droneSystem.destroyDrone(birbHit.index);
          }
        }
      }

      // Update freeze state
      updateFreezeState(delta);

      let pose;
      let visualQuat = null;

      // Update New Flight System
      if (newFlightSystem) {
        const { flight, camera: bCam, visual } = newFlightSystem;

        // inputState already obtained above for aim rig
        const resolvedInput = isNested
          ? { x: 0, y: 0, active: false }
          : inputState;

        // 2. Physics Update
        // IMPORTANT: We pass delta even when nested!
        // BirdFlight.speed will be 0 when nested, preventing position change,
        // but 'tick()' MUST run to allow rotation/orientation updates (Turret Mode).
        pose = flight.tick(resolvedInput, delta);

        // 2b. Object Collision Detection (trees, rocks, etc.)
        // Only check when flying (not nested) and collision system exists
        if (!isNested && sphericalWorld?.collisionSystem) {
          const birdRadius = 0.4; // Bird collision radius
          const collisionResult = sphericalWorld.collisionSystem.checkObjectCollision(
            THREE,
            pose.position,
            birdRadius
          );

          if (collisionResult.collided) {
            // Push bird away from the object
            pose.position.copy(collisionResult.correctedPosition);
            flight.position.copy(collisionResult.correctedPosition);
          }
        }

        if (nestedAimQuaternion) {
          pose.quaternion.copy(nestedAimQuaternion);
          flight.quaternion.copy(nestedAimQuaternion);
        }

        // 3. Camera Update
        // Decide which camera to use:
        // If nested, we might want FPV from 'cameraState' (if it supports spherical)
        // OR we just use bCam but place it at 0 distance?
        // 'nestingSystem' sets cameraMode to FPV.
        // If cameraMode is FPV, 'cameraState' usually handles it.
        // If cameraMode is FOLLOW, 'bCam' handles it.
        const currentMode = cameraState.getMode();

        if (currentMode === CAMERA_MODES.FOLLOW) {
          // Use New Flight Camera
          bCam.update(pose.position, pose.quaternion, delta);
        } else {
          // Use Legacy Camera State (supports FPV, Sequence, Fixed)
          cameraState.updateActiveCamera({ pose, ambientOffsets: null, delta });
        }

        // 4. Visual Update
        visualQuat = visual.update(pose.quaternion, resolvedInput, delta);

        // Disable legacy world rotation
        sphericalWorld.root.quaternion.identity();
      }


      const ambientOffsets = flightController.getAmbientOffsets ? flightController.getAmbientOffsets() : { position: new THREE.Vector3(), quaternion: new THREE.Quaternion() };

      birbAnchor.position.copy(pose.position);
      if (ambientOffsets.position) birbAnchor.position.add(ambientOffsets.position);

      const appliedQuaternion = visualQuat ?? pose.quaternion;
      birbAnchor.quaternion.copy(appliedQuaternion);
      birbAnchor.quaternion.multiply(modelOrientationOffset);
      if (ambientOffsets.quaternion) {
        blendedQuaternion.copy(ambientOffsets.quaternion);
        birbAnchor.quaternion.multiply(blendedQuaternion);
      }
      birbAnchor.quaternion.normalize();

      // Wing banking animation - dip wing on turn direction
      const leftWing = birbAnchor.getObjectByName('leftWing');
      const rightWing = birbAnchor.getObjectByName('rightWing');
      if (leftWing && rightWing && leftWing.userData.baseRotation && rightWing.userData.baseRotation) {
        // Get yaw input from flight controller (-1 = left, +1 = right)
        const yawInput = flightController?.smoothedYaw ?? flightController?.input?.yaw ?? 0;
        const wingDipAmount = 0.4; // Max wing dip angle in radians

        // Left turn (negative yaw): left wing dips down, right wing rises
        // Right turn (positive yaw): right wing dips down, left wing rises
        const leftDip = yawInput * wingDipAmount;  // Positive yaw = left rises
        const rightDip = -yawInput * wingDipAmount; // Positive yaw = right dips

        leftWing.rotation.x = leftWing.userData.baseRotation.x + leftDip;
        rightWing.rotation.x = rightWing.userData.baseRotation.x + rightDip;
      }

      if (glideTrail && glideTrail.rotation) {
        glideTrail.rotation.z = motionState.elapsed * 0.32;
      }

      if (motionState.animate && !controlState.systemPaused) {
        // Safe check for getSpeed
        const speed = typeof flightController.getSpeed === 'function' ? flightController.getSpeed() : flightController.speed;
        updateControlMetrics(speed);
      }

      updateFpsReadout(time);

      // Update camera debug if active
      if (debugVectorState) {
        debugVectorState.update({
          pose,
          ambientOffsets,
          camera: cameraState.camera,
        });
      }

      headingTelemetry?.update(flightController);
      renderer.render(scene, cameraState.camera);
    };

    function handleContextLost(event) {
      event.preventDefault();
      contextState.lost = true;
      previousTime = null;
      flightControls?.reset?.({ releasePointerLock: true });
      renderer.setAnimationLoop(null);
      if (statusMetric) {
        statusMetric.textContent = "Graphics context lost — attempting to restore...";
      }
    }

    function handleContextRestored() {
      contextState.lost = false;
      renderer.state?.reset?.();
      scheduleRendererResize(true);
      renderer.setAnimationLoop(document.hidden ? null : renderFrame);
      renderFrame(0);
      if (statusMetric) {
        statusMetric.textContent = "Graphics restored. Ready to fly.";
      }
    }

    canvas.addEventListener("webglcontextlost", handleContextLost, false);
    canvas.addEventListener("webglcontextrestored", handleContextRestored, false);

    renderer.setAnimationLoop(renderFrame);

    if (statusMetric) {
      statusMetric.textContent = "Ready to fly! Use touch controls or arrow keys.";
    }

    document.addEventListener("visibilitychange", () => {
      if (document.hidden) {
        previousTime = null;
        flightControls.reset({ releasePointerLock: true });
        fpsState.lastSampleTime = null;
        fpsState.frames = 0;
        if (fpsMetric) {
          fpsMetric.textContent = "--";
        }
      } else {
        flightControls.reset();
      }
      renderer.setAnimationLoop(document.hidden ? null : renderFrame);
    });

    window.addEventListener("beforeunload", () => {
      renderer.setAnimationLoop(null);
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
      if (cameraState) {
        cameraState.dispose();
      }
      if (nestingSystem) {
        nestingSystem.dispose();
      }
      if (nestPointsSystem) {
        nestPointsSystem.dispose();
      }
      if (rocketSystem) {
        rocketSystem.dispose();
      }
      if (droneSystem) {
        droneSystem.dispose();
      }
      renderer.dispose();
      if (sphericalWorld) {
        sphericalWorld.dispose();
        sphericalWorld = null;
      }
      if (debugVectorState) {
        debugVectorState.dispose();
      }
      flightControls.dispose();
    });

    scheduleRendererResize(true);
    renderFrame(0);
  </script>
</body>

</html>
