<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Birb Flight Lab</title>
    <meta
      name="description"
      content="Mobile-first Three.js playground for experimenting with gliding capsules."
    />
    <meta name="theme-color" content="#0b0d17" />
    <style>
      :root {
        color-scheme: dark;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        --space-2: clamp(0.75rem, 1.5vw + 0.35rem, 1.1rem);
        --space-3: clamp(1rem, 1.5vw + 0.6rem, 1.5rem);
        --space-4: clamp(1.25rem, 2vw + 0.75rem, 1.9rem);
        --max-width: min(92vw, 42rem);
        --header-size: clamp(0.75rem, 1vw + 0.65rem, 1.1rem);
        --status-size: clamp(0.6rem, 0.7vw + 0.55rem, 0.75rem);
        background-color: #0a1324;
      }

      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        min-height: 100dvh;
        display: flex;
        align-items: stretch;
        justify-content: center;
        background: radial-gradient(circle at 30% 20%, #273d68, #0a1324 68%);
        color: #f6f8ff;
      }

      main {
        width: 100%;
        max-width: var(--max-width);
        display: flex;
        flex-direction: column;
        gap: var(--space-3);
        padding: var(--space-3) var(--space-3) calc(var(--space-3) + 3rem);
      }

      header {
        text-align: center;
        text-transform: uppercase;
        letter-spacing: 0.12em;
        font-size: var(--header-size);
        opacity: 0.75;
      }

      .canvas-wrapper {
        position: relative;
        flex: 1;
        min-height: clamp(18rem, 62vw, 32rem);
        border-radius: 1.5rem;
        overflow: hidden;
        backdrop-filter: blur(16px);
        border: 1px solid rgba(186, 210, 255, 0.12);
        box-shadow: 0 26px 56px rgba(6, 14, 29, 0.6);
        padding-bottom: clamp(2.5rem, 16vw, 5.25rem);
      }

      canvas {
        width: 100%;
        height: 100%;
        display: block;
        background: transparent;
      }

      .control-panel {
        position: absolute;
        top: calc(100% + 0.85rem);
        right: 0;
        display: flex;
        flex-direction: column;
        gap: 0.55rem;
        padding: 0.75rem 0.85rem 0.95rem;
        width: min(16rem, 70vw);
        background: rgba(14, 23, 41, 0.88);
        border-radius: 1rem;
        border: 1px solid rgba(124, 170, 255, 0.22);
        box-shadow: 0 18px 46px rgba(7, 14, 32, 0.55);
        backdrop-filter: blur(18px);
        z-index: 4;
        transform-origin: top right;
        transition: opacity 160ms ease, transform 200ms ease;
      }

      .control-panel.is-collapsed {
        opacity: 0;
        transform: translateY(-0.65rem) scale(0.96);
        pointer-events: none;
      }

      .control-panel h2 {
        margin: 0;
        font-size: 0.72rem;
        text-transform: uppercase;
        letter-spacing: 0.16em;
        opacity: 0.7;
      }

      .control-button {
        appearance: none;
        border: 1px solid rgba(176, 209, 255, 0.36);
        border-radius: 999px;
        padding: 0.45rem 0.95rem;
        font-size: 0.72rem;
        font-weight: 600;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #f3f7ff;
        background: linear-gradient(135deg, rgba(64, 105, 184, 0.55), rgba(26, 44, 92, 0.9));
        box-shadow: inset 0 0 0 1px rgba(32, 62, 124, 0.45);
        cursor: pointer;
        transition: transform 150ms ease, box-shadow 150ms ease, border-color 150ms ease;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
      }

      .control-button[disabled] {
        cursor: not-allowed;
        opacity: 0.6;
        border-color: rgba(176, 209, 255, 0.18);
        box-shadow: none;
      }

      .control-button:focus-visible {
        outline: 2px solid rgba(124, 170, 255, 0.75);
        outline-offset: 2px;
      }

      .control-button:not([disabled]):hover {
        box-shadow: inset 0 0 0 1px rgba(108, 150, 226, 0.6), 0 8px 16px rgba(8, 17, 40, 0.45);
        border-color: rgba(206, 230, 255, 0.72);
        transform: translateY(-1px);
      }

      .control-button:not([disabled]):active {
        transform: translateY(0);
      }

      .control-slider {
        display: grid;
        grid-template-columns: auto minmax(0, 1fr);
        align-items: center;
        gap: 0.4rem 0.6rem;
        font-size: 0.7rem;
        letter-spacing: 0.06em;
        color: rgba(225, 233, 255, 0.85);
      }

      .control-slider label {
        text-transform: uppercase;
      }

      .control-slider input[type="range"] {
        -webkit-appearance: none;
        width: 100%;
        height: 0.3rem;
        border-radius: 999px;
        background: rgba(34, 56, 107, 0.7);
        outline: none;
        position: relative;
      }

      .control-slider input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 1rem;
        height: 1rem;
        border-radius: 50%;
        background: radial-gradient(circle at 30% 30%, #c4dcff, #5f8dff 60%, #2d4fa0 100%);
        border: 1px solid rgba(184, 208, 255, 0.6);
        box-shadow: 0 4px 10px rgba(13, 24, 53, 0.5);
        cursor: pointer;
      }

      .control-slider input[type="range"]::-moz-range-thumb {
        width: 1rem;
        height: 1rem;
        border-radius: 50%;
        background: radial-gradient(circle at 30% 30%, #c4dcff, #5f8dff 60%, #2d4fa0 100%);
        border: 1px solid rgba(184, 208, 255, 0.6);
        box-shadow: 0 4px 10px rgba(13, 24, 53, 0.5);
        cursor: pointer;
      }

      .control-slider output {
        justify-self: end;
        font-variant-numeric: tabular-nums;
        opacity: 0.85;
      }

      .touch-controls {
        position: absolute;
        inset: auto 0 var(--space-2) 0;
        display: none;
        grid-template-columns: minmax(0, 1fr) auto minmax(0, 1fr);
        align-items: end;
        gap: var(--space-2);
        padding: 0 var(--space-2);
        pointer-events: none;
        z-index: 3;
      }

      .touch-controls > * {
        pointer-events: auto;
      }

      .thumbstick {
        position: relative;
        width: clamp(5.5rem, 28vw, 7.25rem);
        aspect-ratio: 1;
        border-radius: 50%;
        background: rgba(18, 27, 46, 0.6);
        border: 1px solid rgba(168, 204, 255, 0.32);
        box-shadow: 0 12px 32px rgba(7, 13, 28, 0.55);
        backdrop-filter: blur(18px);
        touch-action: none;
        user-select: none;
      }

      .thumbstick::before {
        content: "";
        position: absolute;
        inset: 18%;
        border-radius: 50%;
        border: 1px solid rgba(182, 214, 255, 0.38);
        background: radial-gradient(circle at 35% 35%, rgba(192, 220, 255, 0.52), rgba(104, 148, 226, 0.4) 60%, rgba(46, 74, 132, 0.24) 100%);
        opacity: 0.55;
      }

      .thumbstick__handle {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 42%;
        aspect-ratio: 1;
        border-radius: 50%;
        background: radial-gradient(circle at 30% 30%, #d8e7ff, #7ba6ff 60%, #345cae 100%);
        border: 1px solid rgba(204, 224, 255, 0.7);
        box-shadow: 0 10px 24px rgba(10, 17, 34, 0.62);
        transform: translate(calc(-50% + var(--thumbstick-offset-x, 0px)), calc(-50% + var(--thumbstick-offset-y, 0px)));
        transition: transform 160ms ease;
      }

      .thumbstick.is-active .thumbstick__handle {
        transition: none;
      }

      .lift-controls {
        display: flex;
        flex-direction: column;
        gap: 0.6rem;
        align-items: center;
        justify-content: center;
      }

      .lift-button {
        appearance: none;
        border: 1px solid rgba(176, 209, 255, 0.36);
        border-radius: 999px;
        padding: 0.4rem 1rem;
        font-size: 0.65rem;
        font-weight: 600;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #f3f7ff;
        background: linear-gradient(135deg, rgba(64, 105, 184, 0.58), rgba(26, 44, 92, 0.9));
        box-shadow: inset 0 0 0 1px rgba(32, 62, 124, 0.45);
        touch-action: none;
        user-select: none;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        min-width: clamp(3.6rem, 18vw, 4.75rem);
        text-align: center;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }

      .lift-button__icon {
        font-size: 1.15rem;
        line-height: 1;
      }

      .lift-button.is-active,
      .lift-button:active {
        box-shadow: inset 0 0 0 1px rgba(118, 162, 230, 0.65), 0 8px 18px rgba(9, 16, 34, 0.55);
        border-color: rgba(206, 230, 255, 0.75);
      }

      .canvas-actions {
        position: absolute;
        inset: var(--space-2) var(--space-2) auto auto;
        display: flex;
        flex-direction: column;
        gap: 0.55rem;
        align-items: flex-end;
        z-index: 3;
      }

      .settings-popover {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: flex-end;
      }

      .settings-toggle,
      .fullscreen-toggle {
        padding: 0.4rem;
        width: 2.4rem;
        min-width: auto;
        min-height: 2.4rem;
        border-radius: 50%;
      }

      .settings-toggle svg,
      .fullscreen-toggle svg {
        width: 1.1rem;
        height: 1.1rem;
        fill: none;
        stroke: currentColor;
        stroke-width: 1.6;
      }

      .fullscreen-toggle svg[hidden] {
        display: none;
      }

      .visually-hidden {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      .control-metrics {
        margin-top: 0.35rem;
        padding: 0.6rem 0.75rem;
        border-radius: 0.8rem;
        background: rgba(20, 30, 54, 0.72);
        border: 1px solid rgba(174, 206, 255, 0.2);
        display: flex;
        flex-direction: column;
        gap: 0.45rem;
      }

      .control-metrics__row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 1rem;
        font-size: 0.68rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: rgba(232, 240, 255, 0.92);
      }

      .control-metrics__value {
        font-variant-numeric: tabular-nums;
      }

      .control-metrics__note {
        margin: 0.1rem 0 0;
        font-size: 0.62rem;
        letter-spacing: 0.05em;
        color: rgba(210, 222, 252, 0.78);
      }

      .canvas-action-button {
        padding: 0.4rem 0.9rem;
        border-radius: 999px;
        background: rgba(22, 33, 56, 0.72);
        border: 1px solid rgba(174, 206, 255, 0.3);
        color: #f1f5ff;
        font-size: 0.66rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        font-weight: 600;
        cursor: pointer;
        box-shadow: 0 12px 28px rgba(7, 14, 30, 0.55);
        backdrop-filter: blur(18px);
        -webkit-touch-callout: none;
        user-select: none;
        -webkit-user-select: none;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.35rem;
        min-height: 2.25rem;
        transition: transform 150ms ease, box-shadow 150ms ease, border-color 150ms ease;
      }

      .view-toggle__icon {
        width: 1.1rem;
        height: 1.1rem;
        display: block;
        fill: currentColor;
      }

      .canvas-action-button:focus-visible {
        outline: 2px solid rgba(124, 170, 255, 0.75);
        outline-offset: 2px;
      }

      .canvas-action-button:not([disabled]):hover {
        box-shadow: 0 16px 34px rgba(8, 15, 33, 0.6);
        border-color: rgba(198, 224, 255, 0.7);
      }

      .canvas-action-button:not([disabled]):active {
        transform: translateY(1px);
      }

      .control-toggle,
      .fullscreen-toggle {
        border-color: rgba(124, 170, 255, 0.25);
      }

      body.is-fullscreen-fallback {
        align-items: stretch;
      }

      body.is-fullscreen-fallback main {
        flex: 1;
        display: flex;
        flex-direction: column;
        max-width: none;
        width: 100vw;
        padding: 0;
      }

      body.is-fullscreen-fallback header {
        display: none;
      }

      .canvas-wrapper:fullscreen,
      .canvas-wrapper:-webkit-full-screen,
      .canvas-wrapper.is-fullscreen-fallback {
        max-width: none;
        width: 100vw;
        height: 100vh;
        height: 100dvh;
        min-height: 100vh;
        min-height: 100dvh;
        border-radius: 0;
        border: none;
        box-shadow: none;
        padding-bottom: clamp(3rem, 14vw, 4.5rem);
      }

      .canvas-wrapper:fullscreen .canvas-actions,
      .canvas-wrapper:-webkit-full-screen .canvas-actions,
      .canvas-wrapper.is-fullscreen-fallback .canvas-actions {
        inset: clamp(0.75rem, 3vw, 1.4rem) clamp(0.75rem, 3vw, 1.4rem) auto auto;
      }


      @media (pointer: coarse) {
        .touch-controls {
          display: grid;
        }
      }

      noscript {
        position: fixed;
        inset: auto 0 0 0;
        padding: 1rem;
        text-align: center;
        font-size: 0.85rem;
        background: rgba(6, 9, 18, 0.92);
        color: #eff2fc;
      }

      @media (min-width: 48rem) {
        main {
          padding-bottom: calc(var(--space-4) + 5.5rem);
        }

        .canvas-wrapper {
          min-height: clamp(24rem, 55vh, 38rem);
          border-radius: 2rem;
          padding-bottom: clamp(2rem, 8vw, 3.5rem);
        }

        .control-panel {
          width: clamp(18rem, 32vw, 20rem);
        }

        .control-panel h2 {
          font-size: 0.75rem;
        }

        .control-slider {
          grid-template-columns: auto minmax(9rem, 1fr) auto;
          column-gap: 0.9rem;
        }

        .control-button {
          font-size: 0.75rem;
        }

        .touch-controls {
          display: none;
        }

        .canvas-actions {
          flex-direction: row;
        }
      }
    </style>
  </head>
  <body>
    <main>
      <header>Birb Flight Lab</header>
      <div class="canvas-wrapper">
        <canvas
          id="scene"
          role="img"
          aria-label="Stylized capsule gently gliding through a dark sky"
        ></canvas>
        <div class="canvas-actions" role="group" aria-label="Display options">
          <button
            type="button"
            class="canvas-action-button view-toggle"
            data-control="view-toggle"
            aria-label="Cycle camera view"
          >
            <svg
              class="view-toggle__icon"
              viewBox="0 0 24 24"
              aria-hidden="true"
              focusable="false"
            >
              <path
                d="M2.25 12C4.2 7.7 7.8 5 12 5s7.8 2.7 9.75 7c-1.95 4.3-5.55 7-9.75 7s-7.8-2.7-9.75-7Zm9.75 4a4 4 0 1 0 0-8 4 4 0 0 0 0 8Zm0-1.5a2.5 2.5 0 1 1 0-5 2.5 2.5 0 0 1 0 5Z"
              />
            </svg>
            <span class="visually-hidden" data-view-label>Follow view</span>
          </button>
          <div class="settings-popover">
            <button
              type="button"
              class="canvas-action-button control-toggle settings-toggle"
              data-control="panel-toggle"
              aria-pressed="false"
              aria-expanded="false"
              aria-controls="flight-control-panel"
              aria-label="Show flight controls"
            >
              <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <path
                  d="M12 8.25a3.75 3.75 0 1 0 0 7.5 3.75 3.75 0 0 0 0-7.5Zm9 3.75a1.2 1.2 0 0 0-.84-1.14l-1.74-.58a7.47 7.47 0 0 0-.68-1.66l.87-1.67a1.2 1.2 0 0 0-1.05-1.75h-1.8a7.47 7.47 0 0 0-1.31-.9l-.32-1.82A1.2 1.2 0 0 0 12 1.5c-.57 0-1.06.4-1.17.95l-.32 1.82a7.47 7.47 0 0 0-1.31.9H7.4a1.2 1.2 0 0 0-1.05 1.75l.87 1.67a7.47 7.47 0 0 0-.68 1.66l-1.74.58a1.2 1.2 0 0 0 0 2.28l1.74.58c.16.57.39 1.12.68 1.66l-.87 1.67A1.2 1.2 0 0 0 7.4 19.5h1.8c.4.35.84.66 1.31.9l.32 1.82c.11.55.6.95 1.17.95s1.06-.4 1.17-.95l.32-1.82c.47-.24.91-.55 1.31-.9h1.8c.87 0 1.45-.92 1.05-1.75l-.87-1.67c.29-.54.52-1.09.68-1.66l1.74-.58c.49-.16.84-.62.84-1.14Z"
                />
              </svg>
              <span class="visually-hidden" data-settings-label>Show Controls</span>
            </button>
            <div
              id="flight-control-panel"
              class="control-panel is-collapsed"
              role="group"
              aria-label="Flight controls"
              aria-hidden="true"
            >
              <h2>Controls</h2>
              <button
                type="button"
                class="control-button"
                data-control="toggle"
                aria-pressed="true"
              >
                Pause Glide
              </button>
              <div class="control-slider">
                <label for="glide-speed">Throttle</label>
                <input
                  id="glide-speed"
                  type="range"
                  min="0.2"
                  max="0.8"
                  step="0.01"
                  value="0.36"
                  aria-describedby="glide-speed-display"
                />
                <output id="glide-speed-display" data-display="glide-speed" for="glide-speed">
                  36%
                </output>
              </div>
              <button type="button" class="control-button" data-control="reset">
                Reset Camera
              </button>
              <div class="control-metrics" aria-live="polite" aria-atomic="true">
                <div class="control-metrics__row">
                  <span class="control-metrics__label">Speed</span>
                  <span class="control-metrics__value" data-metric="speed">0.00u/s</span>
                </div>
                <div class="control-metrics__row">
                  <span class="control-metrics__label">Throttle</span>
                  <span class="control-metrics__value" data-metric="throttle">36%</span>
                </div>
                <div class="control-metrics__row">
                  <span class="control-metrics__label">FPS</span>
                  <span class="control-metrics__value" data-metric="fps">--</span>
                </div>
                <p class="control-metrics__note" data-metric="status">
                  Gently gliding in progress…
                </p>
              </div>
            </div>
          </div>
          <button
            type="button"
            class="canvas-action-button fullscreen-toggle"
            data-control="fullscreen"
            aria-pressed="false"
            aria-label="Enter fullscreen"
          >
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" data-icon="enter">
              <path
                d="M9 5H5v4M15 5h4v4M9 19H5v-4M15 19h4v-4"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
            <svg
              viewBox="0 0 24 24"
              aria-hidden="true"
              focusable="false"
              data-icon="exit"
              hidden
            >
              <path
                d="M9 7H7V5M17 7V5h-2M9 17v2H7M17 17h-2v2"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
              <path
                d="M15 9h4M15 15h4M5 9h4M5 15h4"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
            <span class="visually-hidden" data-fullscreen-label>Enter Fullscreen</span>
          </button>
        </div>
        <div class="touch-controls" aria-hidden="true">
          <div class="thumbstick" data-thumbstick="left">
            <div class="thumbstick__handle" data-thumbstick-handle></div>
          </div>
          <div class="lift-controls">
            <button type="button" class="lift-button" data-lift-button data-lift="1">
              <span aria-hidden="true" class="lift-button__icon">▲</span>
              <span class="visually-hidden">Ascend (Space/E)</span>
            </button>
            <button type="button" class="lift-button" data-lift-button data-lift="-1">
              <span aria-hidden="true" class="lift-button__icon">▼</span>
              <span class="visually-hidden">Descend (Shift/Q)</span>
            </button>
          </div>
          <div class="thumbstick" data-thumbstick="right">
            <div class="thumbstick__handle" data-thumbstick-handle></div>
          </div>
        </div>
      </div>
    </main>
    <noscript>Enable JavaScript to view the Birb Flight Lab experience.</noscript>

    <script type="module">
      import * as THREE from "https://esm.sh/three@0.161.0";
      import { FreeFlightController } from "./free-flight-controller.js";
      import {
        createCameraState,
        CAMERA_MODES,
      } from "./src/camera/camera-state.js";
      import { createWorldShell } from "./src/environment/world-shell.js";

      const canvasWrapper = document.querySelector(".canvas-wrapper");
      const canvas = document.querySelector("#scene");
      const renderer = new THREE.WebGLRenderer({
        canvas,
        antialias: true,
        alpha: true,
      });

      const DPR_CAP = 1.8;
      const resizeState = { width: 0, height: 0 };

      function clamp(value, min, max) {
        if (!Number.isFinite(value)) {
          return 0;
        }
        return Math.min(Math.max(value, min), max);
      }

      function createThumbstick(root, { onChange } = {}) {
        if (!root) return null;

        const handle = root.querySelector("[data-thumbstick-handle]");
        if (!handle) return null;

        const DEADZONE = 0.12;
        const state = {
          pointerId: null,
          pointerType: null,
          value: { x: 0, y: 0 },
          handleValue: { x: 0, y: 0 },
          captured: false,
          globalListeners: false,
        };

        const listenerOptions = { passive: false };

        const updateVisuals = () => {
          const maxDistance = (root.clientWidth - handle.clientWidth) / 2;
          const offsetX = state.handleValue.x * maxDistance;
          const offsetY = state.handleValue.y * maxDistance;
          handle.style.setProperty("--thumbstick-offset-x", `${offsetX}px`);
          handle.style.setProperty("--thumbstick-offset-y", `${offsetY}px`);
          const active = state.pointerId !== null || Math.hypot(offsetX, offsetY) > 0.5;
          root.classList.toggle("is-active", active);
        };

        const emitChange = () => {
          if (typeof onChange === "function") {
            onChange(
              { x: state.value.x, y: state.value.y },
              { isActive: state.pointerId !== null, pointerType: state.pointerType }
            );
          }
        };

        const setValues = ({ handleX = 0, handleY = 0, outputX = 0, outputY = 0 } = {}) => {
          state.handleValue.x = handleX;
          state.handleValue.y = handleY;
          state.value.x = outputX;
          state.value.y = outputY;
          updateVisuals();
          emitChange();
        };

        const translatePointer = (event) => {
          const rect = root.getBoundingClientRect();
          const maxDistance = rect.width / 2;
          if (maxDistance <= 0) {
            setValues();
            return;
          }
          const dx = event.clientX - (rect.left + rect.width / 2);
          const dy = event.clientY - (rect.top + rect.height / 2);
          let normalizedX = dx / maxDistance;
          let normalizedY = dy / maxDistance;
          const length = Math.hypot(normalizedX, normalizedY);
          if (length > 1) {
            normalizedX /= length;
            normalizedY /= length;
          }

          const handleMagnitude = Math.hypot(normalizedX, normalizedY);
          let outputX = 0;
          let outputY = 0;

          if (handleMagnitude > DEADZONE) {
            const scaledMagnitude = (handleMagnitude - DEADZONE) / (1 - DEADZONE);
            const dirX = handleMagnitude === 0 ? 0 : normalizedX / handleMagnitude;
            const dirY = handleMagnitude === 0 ? 0 : normalizedY / handleMagnitude;
            outputX = dirX * scaledMagnitude;
            outputY = dirY * scaledMagnitude;
          }

          setValues({ handleX: normalizedX, handleY: normalizedY, outputX, outputY });
        };

        const resetValues = () => {
          setValues({ handleX: 0, handleY: 0, outputX: 0, outputY: 0 });
        };

        const attachGlobalListeners = () => {
          if (state.globalListeners || typeof window === "undefined") {
            return;
          }
          window.addEventListener("pointermove", handlePointerMove, listenerOptions);
          window.addEventListener("pointerup", handlePointerEnd, listenerOptions);
          window.addEventListener("pointercancel", handlePointerEnd, listenerOptions);
          state.globalListeners = true;
        };

        const detachGlobalListeners = () => {
          if (!state.globalListeners || typeof window === "undefined") {
            return;
          }
          window.removeEventListener("pointermove", handlePointerMove, listenerOptions);
          window.removeEventListener("pointerup", handlePointerEnd, listenerOptions);
          window.removeEventListener("pointercancel", handlePointerEnd, listenerOptions);
          state.globalListeners = false;
        };

        const handlePointerDown = (event) => {
          if (state.pointerId !== null && state.pointerId !== event.pointerId) {
            return;
          }
          event.preventDefault();
          const supportsPointerCapture =
            typeof root.setPointerCapture === "function" &&
            typeof root.releasePointerCapture === "function";
          const shouldCapture = supportsPointerCapture && event.pointerType !== "touch";
          if (shouldCapture) {
            try {
              root.setPointerCapture(event.pointerId);
              state.captured = true;
            } catch (error) {
              state.captured = false;
            }
          } else {
            state.captured = false;
          }
          state.pointerId = event.pointerId;
          state.pointerType = event.pointerType || null;
          attachGlobalListeners();
          translatePointer(event);
        };

        const resetPointerState = () => {
          if (state.pointerId === null) {
            detachGlobalListeners();
            state.captured = false;
            return;
          }
          if (state.captured && typeof root.releasePointerCapture === "function") {
            const hasCapture =
              typeof root.hasPointerCapture === "function"
                ? root.hasPointerCapture(state.pointerId)
                : true;
            if (hasCapture) {
              try {
                root.releasePointerCapture(state.pointerId);
              } catch (error) {
                // Ignore release failures to avoid breaking touch input fallbacks.
              }
            }
          }
          state.pointerId = null;
          state.pointerType = null;
          state.captured = false;
          detachGlobalListeners();
        };

        const handlePointerMove = (event) => {
          if (state.pointerId !== event.pointerId) return;
          event.preventDefault();
          translatePointer(event);
        };

        const handlePointerEnd = (event) => {
          if (state.pointerId !== event.pointerId) return;
          event.preventDefault();
          resetPointerState();
          resetValues();
        };

        root.addEventListener("pointerdown", handlePointerDown, listenerOptions);
        root.addEventListener("lostpointercapture", handlePointerEnd, listenerOptions);

        resetValues();

        return {
          reset() {
            resetPointerState();
            resetValues();
          },
          destroy() {
            root.removeEventListener("pointerdown", handlePointerDown, listenerOptions);
            root.removeEventListener("lostpointercapture", handlePointerEnd, listenerOptions);
            resetPointerState();
            resetValues();
          },
        };
      }

      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.08;

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a1426);
      scene.fog = new THREE.Fog(0x0a1426, 10.5, 30);

      const ambient = new THREE.HemisphereLight(0xc9e5ff, 0x0f2037, 0.78);
      ambient.groundColor.set(0x13243b);
      scene.add(ambient);

      const keyLight = new THREE.DirectionalLight(0xb7d5ff, 0.88);
      keyLight.position.set(4.2, 4.6, 3.4);
      scene.add(keyLight);

      const rimLight = new THREE.DirectionalLight(0xffd6b9, 0.4);
      rimLight.position.set(-3.2, 3.2, -2.6);
      scene.add(rimLight);

      const fillLight = new THREE.DirectionalLight(0x7fb3ff, 0.35);
      fillLight.position.set(0.8, 2.4, -3.8);
      scene.add(fillLight);

      const glowLight = new THREE.PointLight(0x64c2ff, 1.1, 9.5, 1.6);
      glowLight.position.set(0.1, 1.1, 0.45);
      scene.add(glowLight);

      const { glideTrail } = createWorldShell(scene, { three: THREE });

      const capsuleGroup = new THREE.Group();
      scene.add(capsuleGroup);
      capsuleGroup.scale.setScalar(0.44);

      // Align the capsule's nose (modeled along the +X axis) with the
      // controller's forward vector (-Z) so the beak points in the direction of
      // flight.
      const capsuleOrientationOffset = new THREE.Quaternion().setFromEuler(
        new THREE.Euler(0, Math.PI / 2, 0)
      );

      const bodyGeometry = new THREE.CapsuleGeometry(0.24, 1.2, 20, 40);
      const bodyMaterial = new THREE.MeshStandardMaterial({
        color: 0xd5e6ff,
        metalness: 0.28,
        roughness: 0.34,
        emissive: 0x17305c,
        emissiveIntensity: 0.14,
      });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.castShadow = false;
      body.receiveShadow = false;
      body.rotation.z = Math.PI / 2;
      capsuleGroup.add(body);

      const fuselageBandGeometry = new THREE.CylinderGeometry(0.26, 0.26, 0.18, 32, 1, true);
      const fuselageBandMaterial = new THREE.MeshStandardMaterial({
        color: 0x7da8ff,
        metalness: 0.36,
        roughness: 0.3,
        transparent: true,
        opacity: 0.68,
        emissive: 0x1a2f58,
        emissiveIntensity: 0.16,
      });
      const fuselageBand = new THREE.Mesh(fuselageBandGeometry, fuselageBandMaterial);
      fuselageBand.rotation.z = Math.PI / 2;
      fuselageBand.position.set(-0.08, -0.01, 0);
      capsuleGroup.add(fuselageBand);

      const canopyGeometry = new THREE.SphereGeometry(0.2, 24, 18);
      const canopyMaterial = bodyMaterial.clone();
      canopyMaterial.color = new THREE.Color(0xf5fbff);
      canopyMaterial.roughness = 0.28;
      canopyMaterial.emissiveIntensity = 0.1;
      const canopy = new THREE.Mesh(canopyGeometry, canopyMaterial);
      canopy.position.set(0.46, 0.16, 0);
      capsuleGroup.add(canopy);

      const visorGeometry = new THREE.SphereGeometry(0.2, 18, 16, 0, Math.PI * 1.3);
      const visorMaterial = new THREE.MeshStandardMaterial({
        color: 0x4e94ff,
        metalness: 0.52,
        roughness: 0.16,
        transparent: true,
        opacity: 0.88,
        emissive: 0x0d2245,
        emissiveIntensity: 0.32,
      });
      const visor = new THREE.Mesh(visorGeometry, visorMaterial);
      visor.rotation.y = Math.PI / 2;
      visor.rotation.z = Math.PI / 2;
      visor.position.set(0.7, 0.08, 0);
      capsuleGroup.add(visor);

      const noseGeometry = new THREE.ConeGeometry(0.1, 0.32, 24);
      const noseMaterial = new THREE.MeshStandardMaterial({
        color: 0xffd4a3,
        metalness: 0.18,
        roughness: 0.38,
        emissive: 0x4a230f,
        emissiveIntensity: 0.12,
      });
      const nose = new THREE.Mesh(noseGeometry, noseMaterial);
      nose.rotation.z = Math.PI / 2;
      nose.position.set(0.98, 0.06, 0);
      capsuleGroup.add(nose);

      const engineGeometry = new THREE.CylinderGeometry(0.12, 0.18, 0.44, 28, 1, true);
      const engineMaterial = new THREE.MeshStandardMaterial({
        color: 0x4c74bf,
        metalness: 0.42,
        roughness: 0.32,
        emissive: 0x0f1e3a,
        emissiveIntensity: 0.26,
      });
      const engine = new THREE.Mesh(engineGeometry, engineMaterial);
      engine.rotation.z = Math.PI / 2;
      engine.position.set(-0.54, -0.02, 0);
      capsuleGroup.add(engine);

      const wingGeometry = new THREE.BoxGeometry(1.6, 0.08, 0.66);
      const wingMaterial = new THREE.MeshStandardMaterial({
        color: 0x6fa9ff,
        metalness: 0.32,
        roughness: 0.3,
        emissive: 0x1a3159,
        emissiveIntensity: 0.18,
      });
      const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
      leftWing.position.set(-0.18, 0.02, 0.6);
      leftWing.rotation.set(-Math.PI / 14, Math.PI / 16, -Math.PI / 30);
      capsuleGroup.add(leftWing);

      const rightWing = leftWing.clone();
      rightWing.position.z *= -1;
      rightWing.rotation.x *= -1;
      rightWing.rotation.y *= -1;
      rightWing.rotation.z *= -1;
      capsuleGroup.add(rightWing);

      const tailplaneGeometry = new THREE.BoxGeometry(0.72, 0.06, 0.32);
      const tailMaterial = new THREE.MeshStandardMaterial({
        color: 0x4b7fd5,
        metalness: 0.26,
        roughness: 0.36,
        emissive: 0x132a52,
        emissiveIntensity: 0.18,
      });
      const tailplane = new THREE.Mesh(tailplaneGeometry, tailMaterial);
      tailplane.position.set(-0.88, -0.02, 0);
      tailplane.rotation.set(-Math.PI / 22, 0, 0);
      capsuleGroup.add(tailplane);

      const tailFinGeometry = new THREE.BoxGeometry(0.18, 0.42, 0.08);
      const tailFin = new THREE.Mesh(tailFinGeometry, tailMaterial.clone());
      tailFin.position.set(-0.82, 0.2, 0);
      tailFin.rotation.set(0, 0, -Math.PI / 36);
      capsuleGroup.add(tailFin);

      const tailLightGeometry = new THREE.SphereGeometry(0.06, 18, 14);
      const tailLightMaterial = new THREE.MeshStandardMaterial({
        color: 0xff9c8a,
        emissive: 0x46140c,
        emissiveIntensity: 0.5,
        roughness: 0.32,
        metalness: 0.08,
      });
      const tailLight = new THREE.Mesh(tailLightGeometry, tailLightMaterial);
      tailLight.position.set(-1.08, 0, 0);
      capsuleGroup.add(tailLight);

      const motionQuery = window.matchMedia("(prefers-reduced-motion: reduce)");
      const motionState = {
        animate: !motionQuery.matches,
        elapsed: 0,
      };

      const fpsState = {
        lastSampleTime: null,
        frames: 0,
        value: 0,
      };

      let previousTime = null;

      const toggleButton = document.querySelector('[data-control="toggle"]');
      const resetButton = document.querySelector('[data-control="reset"]');
      const controlPanel = document.querySelector("#flight-control-panel");
      const panelToggleButton = document.querySelector('[data-control="panel-toggle"]');
      const fullscreenToggleButton = document.querySelector('[data-control="fullscreen"]');
      const viewToggleButton = document.querySelector('[data-control="view-toggle"]');
      const viewToggleLabel = viewToggleButton
        ? viewToggleButton.querySelector('[data-view-label]')
        : null;
      const glideSpeedInput = document.querySelector("#glide-speed");
      const glideSpeedDisplay = document.querySelector('[data-display="glide-speed"]');
      const speedMetric = document.querySelector('[data-metric="speed"]');
      const throttleMetric = document.querySelector('[data-metric="throttle"]');
      const fpsMetric = document.querySelector('[data-metric="fps"]');
      const statusMetric = document.querySelector('[data-metric="status"]');
      const panelToggleLabel = panelToggleButton
        ? panelToggleButton.querySelector('[data-settings-label]')
        : null;
      const fullscreenToggleLabel = fullscreenToggleButton
        ? fullscreenToggleButton.querySelector('[data-fullscreen-label]')
        : null;
      const fullscreenEnterIcon = fullscreenToggleButton
        ? fullscreenToggleButton.querySelector('[data-icon="enter"]')
        : null;
      const fullscreenExitIcon = fullscreenToggleButton
        ? fullscreenToggleButton.querySelector('[data-icon="exit"]')
        : null;

      const controlState = {
        manuallyPaused: false,
        systemPaused: motionQuery.matches,
      };

      const fullscreenState = {
        fallbackActive: false,
      };

      function updateFpsReadout(time) {
        if (!fpsMetric) return;

        if (fpsState.lastSampleTime === null) {
          fpsState.lastSampleTime = time;
          fpsState.frames = 0;
          return;
        }

        fpsState.frames += 1;
        const elapsed = time - fpsState.lastSampleTime;
        if (elapsed < 250) {
          return;
        }

        const fps = (fpsState.frames / elapsed) * 1000;
        fpsState.value = fps;
        fpsState.frames = 0;
        fpsState.lastSampleTime = time;
        const formatted = Math.max(0, Math.round(fps)).toString().padStart(2, "0");
        fpsMetric.textContent = formatted;
      }

      function getCameraModeLabel(mode) {
        switch (mode) {
          case CAMERA_MODES.FPV:
            return "FPV view";
          case CAMERA_MODES.FIXED:
            return "Fixed view";
          case CAMERA_MODES.FOLLOW:
          default:
            return "Follow view";
        }
      }

      function updateViewToggleUi(mode = cameraState?.getMode?.()) {
        if (!viewToggleButton) return;
        const modeLabel = getCameraModeLabel(mode);
        if (viewToggleLabel) {
          viewToggleLabel.textContent = modeLabel;
        }
        viewToggleButton.setAttribute(
          "aria-label",
          `Cycle camera view (current: ${modeLabel})`
        );
        viewToggleButton.setAttribute("title", `Cycle camera view • ${modeLabel}`);
      }

      function updateControlMetrics(speed = flightController.getSpeed()) {
        const throttlePercent = Math.round(flightController.getEffectiveThrottle() * 100);
        const safeSpeed = Number.isFinite(speed) ? speed : 0;
        if (speedMetric) {
          speedMetric.textContent = `${safeSpeed.toFixed(2)}u/s`;
        }
        if (throttleMetric) {
          throttleMetric.textContent = `${throttlePercent}%`;
        }
        if (statusMetric) {
          if (controlState.systemPaused) {
            statusMetric.textContent = "Motion paused via system preference";
          } else if (!motionState.animate) {
            statusMetric.textContent = "Glide paused";
          } else if (flightController.isSprinting) {
            statusMetric.textContent = "Sprinting boost engaged";
          } else {
            const mode = cameraState?.getMode?.();
            const modeLabel = getCameraModeLabel(mode);
            const instruction = viewToggleButton
              ? "tap the eye icon or press V"
              : "press V to change";
            statusMetric.textContent =
              `Gently gliding in progress… (${modeLabel} — ${instruction})`;
          }
        }
      }

      function updateToggleButton() {
        if (controlState.systemPaused) {
          toggleButton.disabled = true;
          toggleButton.setAttribute("aria-pressed", "false");
          toggleButton.textContent = "Motion Disabled";
        } else {
          toggleButton.disabled = false;
          toggleButton.textContent = motionState.animate ? "Pause Glide" : "Resume Glide";
          toggleButton.setAttribute("aria-pressed", motionState.animate ? "true" : "false");
        }
      }

      function refreshAnimationState() {
        motionState.animate = !(controlState.manuallyPaused || controlState.systemPaused);
        if (!motionState.animate) {
          previousTime = null;
        }
        updateToggleButton();
        updateControlMetrics();
      }

      function updatePanelToggle() {
        if (!panelToggleButton || !controlPanel) return;
        const isCollapsed = controlPanel.classList.contains("is-collapsed");
        if (panelToggleLabel) {
          panelToggleLabel.textContent = isCollapsed ? "Show Controls" : "Hide Controls";
        }
        panelToggleButton.setAttribute("aria-pressed", isCollapsed ? "false" : "true");
        panelToggleButton.setAttribute("aria-expanded", isCollapsed ? "false" : "true");
        panelToggleButton.setAttribute(
          "aria-label",
          isCollapsed ? "Show flight controls" : "Hide flight controls"
        );
        controlPanel.setAttribute("aria-hidden", isCollapsed ? "true" : "false");
      }

      function getFullscreenElement() {
        return (
          document.fullscreenElement ||
          document.webkitFullscreenElement ||
          document.mozFullScreenElement ||
          document.msFullscreenElement ||
          null
        );
      }

      function callFullscreenMethod(target, methodNames) {
        if (!target) return null;
        for (const methodName of methodNames) {
          const method = target[methodName];
          if (typeof method === "function") {
            return method.call(target);
          }
        }
        return null;
      }

      function ensurePromise(result) {
        if (result && typeof result.then === "function") {
          return result;
        }
        return Promise.resolve();
      }

      function requestFullscreen(element) {
        const targets = [element, document.documentElement, document.body].filter(Boolean);
        let lastError = null;

        const attemptAtIndex = (index = 0) => {
          if (index >= targets.length) {
            return Promise.reject(lastError ?? new Error("Fullscreen not supported"));
          }

          const target = targets[index];
          const result = callFullscreenMethod(target, [
            "requestFullscreen",
            "webkitRequestFullscreen",
            "mozRequestFullScreen",
            "msRequestFullscreen",
          ]);

          if (result === null) {
            return attemptAtIndex(index + 1);
          }

          return ensurePromise(result)
            .then(() => target)
            .catch((error) => {
              lastError = error;
              return attemptAtIndex(index + 1);
            });
        };

        return attemptAtIndex();
      }

      function exitFullscreen() {
        const result = callFullscreenMethod(document, [
          "exitFullscreen",
          "webkitExitFullscreen",
          "mozCancelFullScreen",
          "msExitFullscreen",
        ]);

        if (!result) {
          return Promise.resolve();
        }

        return ensurePromise(result);
      }

      function isFullscreenActive() {
        if (fullscreenState.fallbackActive) {
          return true;
        }
        const fullscreenElement = getFullscreenElement();
        if (!fullscreenElement) {
          return false;
        }
        return (
          fullscreenElement === canvasWrapper ||
          fullscreenElement === document.documentElement ||
          fullscreenElement === document.body
        );
      }

      function syncFullscreenUi() {
        if (!fullscreenToggleButton) return;
        const fullscreenElement = getFullscreenElement();
        const isDocumentFullscreen =
          fullscreenElement === document.documentElement || fullscreenElement === document.body;
        const isFallbackFullscreen = fullscreenState.fallbackActive && !fullscreenElement;
        const isFullscreen =
          fullscreenElement === canvasWrapper || isDocumentFullscreen || isFallbackFullscreen;
        const labelText = isFullscreen ? "Exit Fullscreen" : "Enter Fullscreen";
        fullscreenToggleButton.setAttribute("aria-pressed", isFullscreen ? "true" : "false");
        fullscreenToggleButton.setAttribute("aria-label", labelText);
        if (fullscreenToggleLabel) {
          fullscreenToggleLabel.textContent = labelText;
        }
        if (fullscreenEnterIcon && fullscreenExitIcon) {
          fullscreenEnterIcon.toggleAttribute("hidden", isFullscreen);
          fullscreenExitIcon.toggleAttribute("hidden", !isFullscreen);
        }
        if (canvasWrapper) {
          const shouldApplyFallback = isDocumentFullscreen || isFallbackFullscreen;
          canvasWrapper.classList.toggle("is-fullscreen-fallback", shouldApplyFallback);
        }
        if (document.body) {
          const shouldApplyFallback = isDocumentFullscreen || isFallbackFullscreen;
          document.body.classList.toggle("is-fullscreen-fallback", shouldApplyFallback);
        }
      }

      function updateGlideSpeedDisplay(value) {
        const throttlePercent = Math.round(value * 100);
        glideSpeedDisplay.textContent = `${throttlePercent}%`;
      }

      motionQuery.addEventListener("change", (event) => {
        controlState.systemPaused = event.matches;
        refreshAnimationState();
      });

      let cameraState = null;
      const CAMERA_MODE_SEQUENCE = [
        CAMERA_MODES.FOLLOW,
        CAMERA_MODES.FPV,
        CAMERA_MODES.FIXED,
      ];
      let cameraModeIndex = 0;

      function updateRendererSize(force = false) {
        const clientWidth = canvas.clientWidth || window.innerWidth;
        const clientHeight = canvas.clientHeight || window.innerHeight;

        if (!clientWidth || !clientHeight) return;

        const nextWidth = Math.floor(clientWidth);
        const nextHeight = Math.floor(clientHeight);

        if (!force && resizeState.width === nextWidth && resizeState.height === nextHeight) {
          return;
        }

        resizeState.width = nextWidth;
        resizeState.height = nextHeight;

        const pixelRatio = Math.min(window.devicePixelRatio || 1, DPR_CAP);
        renderer.setPixelRatio(pixelRatio);
        renderer.setSize(nextWidth, nextHeight, false);
        if (cameraState) {
          const camera = cameraState.camera;
          camera.aspect = nextWidth / nextHeight;
          camera.updateProjectionMatrix();
        }
      }

      const resizeObserver =
        typeof ResizeObserver !== "undefined"
          ? new ResizeObserver(() => updateRendererSize())
          : null;
      if (resizeObserver) {
        resizeObserver.observe(canvas);
      }
      window.addEventListener("orientationchange", () => updateRendererSize(true), {
        passive: true,
      });
      window.addEventListener("resize", () => updateRendererSize(), { passive: true });

      const flightController = new FreeFlightController(THREE, {
        position: new THREE.Vector3(1.1, 0.9, 0),
      });

      cameraState = createCameraState({
        three: THREE,
        scene,
        flightController,
      });

      const syncAvatarVisibility = (mode) => {
        if (!capsuleGroup) return;
        capsuleGroup.visible = mode !== CAMERA_MODES.FPV;
      };

      const setCameraMode = (mode) => {
        if (!cameraState) return;
        cameraState.setMode(mode);
        const index = CAMERA_MODE_SEQUENCE.indexOf(mode);
        if (index !== -1) {
          cameraModeIndex = index;
        }
        syncAvatarVisibility(mode);
        updateControlMetrics();
        updateViewToggleUi(mode);
      };

      const cycleCameraMode = () => {
        const nextIndex = (cameraModeIndex + 1) % CAMERA_MODE_SEQUENCE.length;
        setCameraMode(CAMERA_MODE_SEQUENCE[nextIndex]);
      };

      setCameraMode(CAMERA_MODE_SEQUENCE[cameraModeIndex]);

      const blendedQuaternion = new THREE.Quaternion();
      const thrustKeys = new Set();

      const thrustAxisKeys = {
        forward: {
          positive: ["KeyW", "ArrowUp"],
          negative: ["KeyS", "ArrowDown"],
        },
        strafe: {
          positive: ["KeyD", "ArrowRight"],
          negative: ["KeyA", "ArrowLeft"],
        },
        lift: {
          positive: ["Space", "KeyE"],
          negative: ["KeyQ"],
        },
      };

      const thrustAxes = Object.values(thrustAxisKeys);

      const thrustSources = {
        keys: { forward: 0, strafe: 0, lift: 0 },
        touch: { forward: 0, strafe: 0, lift: 0 },
      };

      const sprintSources = {
        keys: false,
        touch: false,
      };

      function updateSprintState() {
        const isActive = sprintSources.keys || sprintSources.touch;
        flightController.setSprintActive(isActive);
        updateControlMetrics();
      }

      const analogLookInput = { x: 0, y: 0 };
      const ANALOG_LOOK_SPEED = 800;
      const TOUCH_SPRINT_THRESHOLD = 0.75;
      const touchLiftPresses = new Map();
      const liftButtons = Array.from(document.querySelectorAll("[data-lift-button]"));
      const pointerListenerOptions = { passive: false };
      const SHIFT_CODES = new Set(["ShiftLeft", "ShiftRight"]);

      function computeAxisValue(axisKeys) {
        const hasPositive = axisKeys.positive.some((code) => thrustKeys.has(code));
        const hasNegative = axisKeys.negative.some((code) => thrustKeys.has(code));
        if (hasPositive && hasNegative) return 0;
        if (hasPositive) return 1;
        if (hasNegative) return -1;
        return 0;
      }

      function combineThrustAxis(axis) {
        return clamp(
          Object.values(thrustSources).reduce((sum, source) => sum + (source[axis] ?? 0), 0),
          -1,
          1
        );
      }

      function applyThrustInput() {
        flightController.setThrustInput({
          forward: combineThrustAxis("forward"),
          strafe: combineThrustAxis("strafe"),
          lift: combineThrustAxis("lift"),
        });
      }

      function updateThrustFromKeys() {
        thrustSources.keys.forward = computeAxisValue(thrustAxisKeys.forward);
        thrustSources.keys.strafe = computeAxisValue(thrustAxisKeys.strafe);
        thrustSources.keys.lift = computeAxisValue(thrustAxisKeys.lift);
        applyThrustInput();
      }

      const leftThumbstick = createThumbstick(document.querySelector('[data-thumbstick="left"]'), {
        onChange: (value, context = {}) => {
          thrustSources.touch.forward = -value.y;
          thrustSources.touch.strafe = value.x;
          const magnitude = Math.hypot(value.x, value.y);
          const isTouch = context.pointerType === "touch";
          const isActive = Boolean(context.isActive);
          sprintSources.touch = Boolean(isTouch && isActive && magnitude >= TOUCH_SPRINT_THRESHOLD);
          updateSprintState();
          applyThrustInput();
        },
      });

      const rightThumbstick = createThumbstick(document.querySelector('[data-thumbstick="right"]'), {
        onChange: (value) => {
          analogLookInput.x = value.x;
          analogLookInput.y = -value.y;
        },
      });

      const updateLiftFromButtons = () => {
        let lift = 0;
        touchLiftPresses.forEach((value) => {
          lift += value;
        });
        thrustSources.touch.lift = clamp(lift, -1, 1);
        applyThrustInput();
      };

      const handleLiftButtonDown = (event) => {
        event.preventDefault();
        const { currentTarget } = event;
        const direction = Number.parseFloat(currentTarget?.dataset?.lift ?? "0");
        if (!Number.isFinite(direction) || direction === 0) {
          return;
        }
        if (typeof currentTarget.setPointerCapture === "function") {
          currentTarget.setPointerCapture(event.pointerId);
        }
        touchLiftPresses.set(event.pointerId, direction);
        currentTarget.classList.add("is-active");
        updateLiftFromButtons();
      };

      const handleLiftButtonEnd = (event) => {
        const { currentTarget } = event;
        if (typeof currentTarget?.hasPointerCapture === "function" && currentTarget.hasPointerCapture(event.pointerId)) {
          currentTarget.releasePointerCapture(event.pointerId);
        }
        event.preventDefault();
        touchLiftPresses.delete(event.pointerId);
        currentTarget?.classList.remove("is-active");
        updateLiftFromButtons();
      };

      liftButtons.forEach((button) => {
        button.addEventListener("pointerdown", handleLiftButtonDown, pointerListenerOptions);
        button.addEventListener("pointerup", handleLiftButtonEnd, pointerListenerOptions);
        button.addEventListener("pointercancel", handleLiftButtonEnd, pointerListenerOptions);
        button.addEventListener("lostpointercapture", handleLiftButtonEnd, pointerListenerOptions);
        button.addEventListener("contextmenu", (event) => {
          event.preventDefault();
        });
      });

      toggleButton.addEventListener("click", () => {
        if (controlState.systemPaused) return;
        controlState.manuallyPaused = !controlState.manuallyPaused;
        refreshAnimationState();
      });

      if (panelToggleButton && controlPanel) {
        panelToggleButton.addEventListener("click", () => {
          controlPanel.classList.toggle("is-collapsed");
          updatePanelToggle();
        });
        updatePanelToggle();
      }

      if (fullscreenToggleButton && canvasWrapper) {
        fullscreenToggleButton.addEventListener("click", () => {
          const isFullscreen = isFullscreenActive();
          if (isFullscreen && fullscreenState.fallbackActive) {
            fullscreenState.fallbackActive = false;
            syncFullscreenUi();
            updateRendererSize(true);
            return;
          }
          const action = isFullscreen ? exitFullscreen() : requestFullscreen(canvasWrapper);
          if (action && typeof action.then === "function") {
            action
              .then(() => {
                fullscreenState.fallbackActive = false;
                syncFullscreenUi();
                updateRendererSize(true);
              })
              .catch(() => {
                if (!isFullscreen) {
                  fullscreenState.fallbackActive = true;
                } else {
                  fullscreenState.fallbackActive = false;
                }
                syncFullscreenUi();
                updateRendererSize(true);
              });
          } else {
            // Ensure legacy browsers update button state even without promise support.
            fullscreenState.fallbackActive = !isFullscreen;
            setTimeout(() => {
              syncFullscreenUi();
              updateRendererSize(true);
            }, 0);
          }
        });

        const fullscreenEvents = [
          "fullscreenchange",
          "webkitfullscreenchange",
          "mozfullscreenchange",
          "MSFullscreenChange",
        ];

        fullscreenEvents.forEach((eventName) => {
          document.addEventListener(eventName, () => {
            fullscreenState.fallbackActive = false;
            syncFullscreenUi();
            updateRendererSize(true);
          });
        });

        syncFullscreenUi();
      }

      resetButton.addEventListener("click", () => {
        flightController.reset();
        cameraState.reset();
        const currentMode = cameraState.getMode();
        const currentIndex = CAMERA_MODE_SEQUENCE.indexOf(currentMode);
        cameraModeIndex = currentIndex === -1 ? 0 : currentIndex;
        updateViewToggleUi(currentMode);
        thrustKeys.clear();
        updateThrustFromKeys();
        if (leftThumbstick) {
          leftThumbstick.reset();
        }
        if (rightThumbstick) {
          rightThumbstick.reset();
        }
        analogLookInput.x = 0;
        analogLookInput.y = 0;
        touchLiftPresses.clear();
        liftButtons.forEach((button) => button.classList.remove("is-active"));
        updateLiftFromButtons();
        sprintSources.keys = false;
        sprintSources.touch = false;
        updateSprintState();
        updateControlMetrics();
      });

      const initialThrottle = Number.parseFloat(glideSpeedInput.value);
      flightController.setThrottle(Number.isFinite(initialThrottle) ? initialThrottle : 0.36);
      updateGlideSpeedDisplay(flightController.throttle);

      glideSpeedInput.addEventListener("input", (event) => {
        const nextThrottle = Number.parseFloat(event.target.value);
        flightController.setThrottle(Number.isFinite(nextThrottle) ? nextThrottle : flightController.throttle);
        updateGlideSpeedDisplay(flightController.throttle);
        updateControlMetrics();
      });

      applyThrustInput();
      refreshAnimationState();

      document.addEventListener("keydown", (event) => {
        const { code } = event;
        if (event.target && (event.target.isContentEditable || /^(INPUT|TEXTAREA|SELECT)$/.test(event.target.tagName))) {
          return;
        }
        if (code === "KeyV" && !event.repeat) {
          cycleCameraMode();
          event.preventDefault();
          return;
        }
        const isRelevant = thrustAxes.some((axis) =>
          axis.positive.includes(code) || axis.negative.includes(code)
        );
        if (!isRelevant && !isShift) return;
        if (isRelevant) {
          thrustKeys.add(code);
          updateThrustFromKeys();
        }
        if (isShift) {
          sprintSources.keys = true;
          updateSprintState();
        }
        event.preventDefault();
      });

      if (viewToggleButton) {
        viewToggleButton.addEventListener("click", () => {
          cycleCameraMode();
        });
      }

      document.addEventListener("keyup", (event) => {
        const { code } = event;
        if (event.target && (event.target.isContentEditable || /^(INPUT|TEXTAREA|SELECT)$/.test(event.target.tagName))) {
          return;
        }
        const isShift = SHIFT_CODES.has(code);
        const wasRelevant = thrustAxes.some((axis) =>
          axis.positive.includes(code) || axis.negative.includes(code)
        );
        if (!wasRelevant && !isShift) return;
        if (wasRelevant) {
          thrustKeys.delete(code);
          updateThrustFromKeys();
        }
        if (isShift) {
          sprintSources.keys = false;
          updateSprintState();
        }
        event.preventDefault();
      });

      canvas.addEventListener("click", () => {
        if (!window.matchMedia("(pointer: fine)").matches) {
          return;
        }
        if (canvas.requestPointerLock && document.pointerLockElement !== canvas) {
          canvas.requestPointerLock();
        }
      });

      document.addEventListener("mousemove", (event) => {
        if (document.pointerLockElement === canvas) {
          flightController.addLookDelta(event.movementX, event.movementY);
        }
      });

      window.addEventListener("blur", () => {
        thrustKeys.clear();
        updateThrustFromKeys();
        touchLiftPresses.clear();
        liftButtons.forEach((button) => button.classList.remove("is-active"));
        updateLiftFromButtons();
        sprintSources.keys = false;
        sprintSources.touch = false;
        updateSprintState();
        if (leftThumbstick) {
          leftThumbstick.reset();
        }
        if (rightThumbstick) {
          rightThumbstick.reset();
        }
        analogLookInput.x = 0;
        analogLookInput.y = 0;
        if (document.pointerLockElement === canvas && document.exitPointerLock) {
          document.exitPointerLock();
        }
      });

      const renderFrame = (time = 0) => {
        updateRendererSize();

        let delta = 0;
        if (motionState.animate) {
          if (previousTime === null) {
            previousTime = time;
          }
          delta = (time - previousTime) * 0.001;
          motionState.elapsed += delta;
          previousTime = time;
        } else {
          previousTime = null;
        }

        const lookDeltaTime = Math.min(delta > 0 ? delta : 1 / 60, 0.05);
        if (analogLookInput.x !== 0 || analogLookInput.y !== 0) {
          flightController.addLookDelta(
            analogLookInput.x * ANALOG_LOOK_SPEED * lookDeltaTime,
            analogLookInput.y * ANALOG_LOOK_SPEED * lookDeltaTime
          );
        }

        const pose = flightController.update(delta);
        const ambientOffsets = flightController.getAmbientOffsets();

        capsuleGroup.position.copy(pose.position).add(ambientOffsets.position);
        capsuleGroup.quaternion.copy(pose.quaternion);
        capsuleGroup.quaternion.multiply(capsuleOrientationOffset);
        blendedQuaternion.copy(ambientOffsets.quaternion);
        capsuleGroup.quaternion.multiply(blendedQuaternion);
        capsuleGroup.quaternion.normalize();

        glideTrail.rotation.z = motionState.elapsed * 0.32;

        if (motionState.animate && !controlState.systemPaused) {
          updateControlMetrics(flightController.getSpeed());
        }

        updateFpsReadout(time);
        cameraState.updateActiveCamera({ pose, ambientOffsets, delta });
        renderer.render(scene, cameraState.camera);
      };

      renderer.setAnimationLoop(renderFrame);

      document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          previousTime = null;
          if (leftThumbstick) {
            leftThumbstick.reset();
          }
          if (rightThumbstick) {
            rightThumbstick.reset();
          }
          analogLookInput.x = 0;
          analogLookInput.y = 0;
          touchLiftPresses.clear();
          liftButtons.forEach((button) => button.classList.remove("is-active"));
          updateLiftFromButtons();
          sprintSources.keys = false;
          sprintSources.touch = false;
          updateSprintState();
          fpsState.lastSampleTime = null;
          fpsState.frames = 0;
          if (fpsMetric) {
            fpsMetric.textContent = "--";
          }
        }
        renderer.setAnimationLoop(document.hidden ? null : renderFrame);
      });

      window.addEventListener("beforeunload", () => {
        renderer.setAnimationLoop(null);
        if (resizeObserver) {
          resizeObserver.disconnect();
        }
        if (cameraState) {
          cameraState.dispose();
        }
        renderer.dispose();
        if (leftThumbstick) {
          leftThumbstick.destroy();
        }
        if (rightThumbstick) {
          rightThumbstick.destroy();
        }
        liftButtons.forEach((button) => {
          button.removeEventListener("pointerdown", handleLiftButtonDown, pointerListenerOptions);
          button.removeEventListener("pointerup", handleLiftButtonEnd, pointerListenerOptions);
          button.removeEventListener("pointercancel", handleLiftButtonEnd, pointerListenerOptions);
          button.removeEventListener("lostpointercapture", handleLiftButtonEnd, pointerListenerOptions);
        });
      });

      updateRendererSize(true);
      renderFrame(0);
    </script>
  </body>
</html>
