<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Birb Glide</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
    }

    body {
      width: 100vw;
      height: 100dvh;
      overflow: hidden;
      font-family: system-ui, -apple-system, sans-serif;
      background: linear-gradient(180deg, #87CEEB 0%, #E0F6FF 50%, #98D8AA 100%);
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
      touch-action: none;
    }

    #ui {
      position: fixed;
      top: 20px;
      left: 0;
      right: 0;
      text-align: center;
      pointer-events: none;
      z-index: 10;
    }

    #score {
      font-size: 24px;
      font-weight: 600;
      color: #fff;
      text-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }

    #hint {
      position: fixed;
      bottom: 40px;
      left: 0;
      right: 0;
      text-align: center;
      font-size: 16px;
      color: rgba(255,255,255,0.8);
      text-shadow: 0 1px 4px rgba(0,0,0,0.3);
      pointer-events: none;
      transition: opacity 0.5s;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div id="ui">
    <div id="score">ðŸŒŸ 0</div>
  </div>
  <div id="hint">Tilt or drag to glide</div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const hint = document.getElementById('hint');
    const scoreEl = document.getElementById('score');

    // High DPI support
    function resize() {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = window.innerWidth * dpr;
      canvas.height = window.innerHeight * dpr;
      ctx.scale(dpr, dpr);
    }
    resize();
    window.addEventListener('resize', resize);

    // Game state
    const bird = {
      x: window.innerWidth / 2,
      y: window.innerHeight / 3,
      vx: 0,
      vy: 0,
      angle: 0,
      wingPhase: 0
    };

    let score = 0;
    let targetX = bird.x;
    let targetY = bird.y;
    let isDragging = false;
    let hasInteracted = false;

    // Clouds and stars (collectibles)
    const clouds = [];
    const stars = [];

    function spawnCloud() {
      clouds.push({
        x: Math.random() * window.innerWidth,
        y: -100 + Math.random() * window.innerHeight * 0.6,
        size: 40 + Math.random() * 60,
        speed: 0.2 + Math.random() * 0.3
      });
    }

    function spawnStar() {
      stars.push({
        x: Math.random() * window.innerWidth,
        y: -50,
        size: 15 + Math.random() * 10,
        speed: 1 + Math.random() * 2,
        collected: false,
        pulse: Math.random() * Math.PI * 2
      });
    }

    // Initialize
    for (let i = 0; i < 5; i++) {
      spawnCloud();
      clouds[i].y = Math.random() * window.innerHeight * 0.5;
    }

    // Touch/Mouse controls
    function handleStart(x, y) {
      isDragging = true;
      targetX = x;
      targetY = y;
      if (!hasInteracted) {
        hasInteracted = true;
        hint.style.opacity = '0';
      }
    }

    function handleMove(x, y) {
      if (isDragging) {
        targetX = x;
        targetY = y;
      }
    }

    function handleEnd() {
      isDragging = false;
    }

    canvas.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY));
    canvas.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
    canvas.addEventListener('mouseup', handleEnd);
    canvas.addEventListener('mouseleave', handleEnd);

    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      const t = e.touches[0];
      handleStart(t.clientX, t.clientY);
    }, { passive: false });

    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      const t = e.touches[0];
      handleMove(t.clientX, t.clientY);
    }, { passive: false });

    canvas.addEventListener('touchend', handleEnd);

    // Gyroscope (tilt) controls
    if (window.DeviceOrientationEvent) {
      window.addEventListener('deviceorientation', e => {
        if (e.gamma !== null && e.beta !== null) {
          if (!hasInteracted) {
            hasInteracted = true;
            hint.style.opacity = '0';
          }
          // gamma: left-right tilt (-90 to 90)
          // beta: front-back tilt (-180 to 180)
          const tiltX = Math.max(-30, Math.min(30, e.gamma)) / 30;
          const tiltY = Math.max(-30, Math.min(30, e.beta - 30)) / 30;

          if (!isDragging) {
            targetX = bird.x + tiltX * 100;
            targetY = bird.y + tiltY * 100;
          }
        }
      });
    }

    // Draw bird
    function drawBird() {
      ctx.save();
      ctx.translate(bird.x, bird.y);
      ctx.rotate(bird.angle);

      // Wing animation
      bird.wingPhase += 0.15;
      const wingFlap = Math.sin(bird.wingPhase) * 0.3;

      // Body
      ctx.fillStyle = '#FFD93D';
      ctx.beginPath();
      ctx.ellipse(0, 0, 25, 18, 0, 0, Math.PI * 2);
      ctx.fill();

      // Wing (left)
      ctx.fillStyle = '#FFC107';
      ctx.save();
      ctx.rotate(-0.3 + wingFlap);
      ctx.beginPath();
      ctx.ellipse(-10, -5, 20, 8, -0.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // Wing (right)
      ctx.save();
      ctx.rotate(0.3 - wingFlap);
      ctx.beginPath();
      ctx.ellipse(-10, 5, 20, 8, 0.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // Beak
      ctx.fillStyle = '#FF6B35';
      ctx.beginPath();
      ctx.moveTo(20, 0);
      ctx.lineTo(35, -3);
      ctx.lineTo(35, 3);
      ctx.closePath();
      ctx.fill();

      // Eye
      ctx.fillStyle = '#333';
      ctx.beginPath();
      ctx.arc(12, -5, 5, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(13, -6, 2, 0, Math.PI * 2);
      ctx.fill();

      // Tail feathers
      ctx.fillStyle = '#FFC107';
      ctx.beginPath();
      ctx.moveTo(-20, 0);
      ctx.lineTo(-35, -8);
      ctx.lineTo(-30, 0);
      ctx.lineTo(-35, 8);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }

    // Draw cloud
    function drawCloud(cloud) {
      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      const s = cloud.size;
      ctx.beginPath();
      ctx.arc(cloud.x, cloud.y, s * 0.5, 0, Math.PI * 2);
      ctx.arc(cloud.x - s * 0.4, cloud.y + s * 0.1, s * 0.35, 0, Math.PI * 2);
      ctx.arc(cloud.x + s * 0.4, cloud.y + s * 0.1, s * 0.4, 0, Math.PI * 2);
      ctx.arc(cloud.x - s * 0.2, cloud.y + s * 0.3, s * 0.3, 0, Math.PI * 2);
      ctx.arc(cloud.x + s * 0.2, cloud.y + s * 0.3, s * 0.35, 0, Math.PI * 2);
      ctx.fill();
    }

    // Draw star
    function drawStar(star) {
      if (star.collected) return;

      star.pulse += 0.1;
      const pulse = 1 + Math.sin(star.pulse) * 0.2;
      const s = star.size * pulse;

      ctx.fillStyle = '#FFD700';
      ctx.shadowColor = '#FFD700';
      ctx.shadowBlur = 15;

      ctx.beginPath();
      for (let i = 0; i < 5; i++) {
        const angle = (i * Math.PI * 2) / 5 - Math.PI / 2;
        const outerX = star.x + Math.cos(angle) * s;
        const outerY = star.y + Math.sin(angle) * s;
        const innerAngle = angle + Math.PI / 5;
        const innerX = star.x + Math.cos(innerAngle) * s * 0.4;
        const innerY = star.y + Math.sin(innerAngle) * s * 0.4;

        if (i === 0) ctx.moveTo(outerX, outerY);
        else ctx.lineTo(outerX, outerY);
        ctx.lineTo(innerX, innerY);
      }
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    // Draw ground/hills
    function drawGround(time) {
      const h = window.innerHeight;
      const w = window.innerWidth;

      // Back hills
      ctx.fillStyle = '#7CB342';
      ctx.beginPath();
      ctx.moveTo(0, h);
      for (let x = 0; x <= w; x += 50) {
        const y = h - 80 + Math.sin((x + time * 20) * 0.01) * 30;
        ctx.lineTo(x, y);
      }
      ctx.lineTo(w, h);
      ctx.closePath();
      ctx.fill();

      // Front hills
      ctx.fillStyle = '#8BC34A';
      ctx.beginPath();
      ctx.moveTo(0, h);
      for (let x = 0; x <= w; x += 50) {
        const y = h - 40 + Math.sin((x + time * 40) * 0.015) * 20;
        ctx.lineTo(x, y);
      }
      ctx.lineTo(w, h);
      ctx.closePath();
      ctx.fill();
    }

    // Game loop
    let lastTime = 0;
    let gameTime = 0;

    function update(timestamp) {
      const dt = Math.min((timestamp - lastTime) / 16.67, 3);
      lastTime = timestamp;
      gameTime += dt;

      const w = window.innerWidth;
      const h = window.innerHeight;

      // Clear
      ctx.clearRect(0, 0, w, h);

      // Draw background gradient
      const gradient = ctx.createLinearGradient(0, 0, 0, h);
      gradient.addColorStop(0, '#87CEEB');
      gradient.addColorStop(0.5, '#B8E4F9');
      gradient.addColorStop(1, '#98D8AA');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, w, h);

      // Update and draw clouds
      clouds.forEach(cloud => {
        cloud.y += cloud.speed * dt;
        if (cloud.y > h + 100) {
          cloud.y = -100;
          cloud.x = Math.random() * w;
        }
        drawCloud(cloud);
      });

      // Spawn stars occasionally
      if (Math.random() < 0.02 * dt) {
        spawnStar();
      }

      // Update and draw stars
      stars.forEach(star => {
        if (!star.collected) {
          star.y += star.speed * dt;

          // Check collision with bird
          const dx = star.x - bird.x;
          const dy = star.y - bird.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist < 40) {
            star.collected = true;
            score++;
            scoreEl.textContent = 'ðŸŒŸ ' + score;
          }
        }
        drawStar(star);
      });

      // Remove old stars
      for (let i = stars.length - 1; i >= 0; i--) {
        if (stars[i].y > h + 50 || stars[i].collected) {
          stars.splice(i, 1);
        }
      }

      // Bird physics - smooth gliding toward target
      const dx = targetX - bird.x;
      const dy = targetY - bird.y;

      bird.vx += dx * 0.002 * dt;
      bird.vy += dy * 0.002 * dt;

      // Add gentle floating motion when idle
      if (!isDragging && !hasInteracted) {
        bird.vy += Math.sin(gameTime * 0.05) * 0.1;
      }

      // Damping
      bird.vx *= 0.95;
      bird.vy *= 0.95;

      // Apply velocity
      bird.x += bird.vx * dt;
      bird.y += bird.vy * dt;

      // Keep bird on screen
      bird.x = Math.max(40, Math.min(w - 40, bird.x));
      bird.y = Math.max(40, Math.min(h - 100, bird.y));

      // Bird angle based on velocity
      const targetAngle = Math.atan2(bird.vy, Math.max(bird.vx, 1)) * 0.5;
      bird.angle += (targetAngle - bird.angle) * 0.1;

      // Draw ground
      drawGround(gameTime);

      // Draw bird
      drawBird();

      requestAnimationFrame(update);
    }

    requestAnimationFrame(update);
  </script>
</body>
</html>
