<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Birb Mobile Test</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      -webkit-user-select: none;
    }

    body {
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: #0a1426;
      font-family: system-ui, sans-serif;
      color: #fff;
      touch-action: none;
    }

    #canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    #status {
      position: fixed;
      top: 10px;
      left: 10px;
      right: 10px;
      padding: 10px;
      background: rgba(0,0,0,0.7);
      border-radius: 8px;
      font-size: 12px;
      z-index: 100;
      max-height: 40vh;
      overflow-y: auto;
    }

    #status.success {
      background: rgba(0,100,0,0.7);
    }

    #status.error {
      background: rgba(100,0,0,0.7);
    }

    /* Joystick */
    #joystick-zone {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 50%;
      height: 40%;
      z-index: 50;
    }

    #joystick {
      display: none;
      position: fixed;
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: rgba(255,255,255,0.15);
      border: 2px solid rgba(255,255,255,0.3);
      z-index: 51;
      pointer-events: none;
    }

    #joystick-thumb {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 50px;
      height: 50px;
      margin: -25px;
      border-radius: 50%;
      background: rgba(255,255,255,0.5);
    }

    #joystick.active {
      display: block;
    }

    /* Speed display */
    #hud {
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 10px;
      background: rgba(0,0,0,0.5);
      border-radius: 8px;
      font-size: 14px;
      z-index: 100;
    }
  </style>
</head>
<body>
  <div id="status">Initializing...</div>
  <canvas id="canvas"></canvas>
  <div id="joystick-zone"></div>
  <div id="joystick"><div id="joystick-thumb"></div></div>
  <div id="hud">
    <div>Speed: <span id="speed">0</span> m/s</div>
    <div>Alt: <span id="alt">0</span> m</div>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    // ============================================
    // MINIMAL MOBILE 3D TEST - Starting from scratch
    // ============================================

    const statusEl = document.getElementById('status');
    const log = (msg) => {
      console.log(msg);
      statusEl.textContent = msg;
    };

    const error = (msg, e) => {
      console.error(msg, e);
      statusEl.textContent = `ERROR: ${msg}\n${e?.message || ''}`;
      statusEl.className = 'error';
    };

    // ============================================
    // STEP 1: Import Three.js
    // ============================================
    log('Step 1: Importing Three.js...');

    let THREE, GLTFLoader;

    try {
      THREE = await import('three');
      const loaderModule = await import('three/addons/loaders/GLTFLoader.js');
      GLTFLoader = loaderModule.GLTFLoader;
      log('Step 1 complete: Three.js imported');
    } catch (e) {
      error('Failed to import Three.js', e);
      throw e;
    }

    // ============================================
    // STEP 2: Create WebGL renderer (simplest config)
    // ============================================
    log('Step 2: Creating renderer...');

    const canvas = document.getElementById('canvas');
    let renderer;

    try {
      // Most basic renderer config possible
      renderer = new THREE.WebGLRenderer({
        canvas,
        antialias: false,
        alpha: false,
        depth: true,
        stencil: false,
        powerPreference: 'default'
      });

      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);

      log('Step 2 complete: Renderer created');
      statusEl.className = 'success';
    } catch (e) {
      error('Failed to create renderer', e);
      throw e;
    }

    // ============================================
    // STEP 3: Create scene, camera, lights
    // ============================================
    log('Step 3: Creating scene...');

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb); // Sky blue

    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 2, 5);

    // Simple lighting
    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambient);

    const sun = new THREE.DirectionalLight(0xffffff, 1);
    sun.position.set(5, 10, 5);
    scene.add(sun);

    // Ground plane for reference
    const groundGeo = new THREE.PlaneGeometry(100, 100);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x3a7d44 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    scene.add(ground);

    log('Step 3 complete: Scene created');

    // ============================================
    // STEP 4: Load birb model
    // ============================================
    log('Step 4: Loading birb model...');

    const birb = new THREE.Group();
    birb.position.set(0, 5, 0);
    scene.add(birb);

    // Create placeholder cube while model loads
    const placeholder = new THREE.Mesh(
      new THREE.BoxGeometry(0.5, 0.3, 0.8),
      new THREE.MeshStandardMaterial({ color: 0x4444ff })
    );
    birb.add(placeholder);

    const loader = new GLTFLoader();
    loader.load(
      './birb.glb',
      (gltf) => {
        log('Birb model loaded!');
        birb.remove(placeholder);
        const model = gltf.scene;
        model.scale.setScalar(1);
        birb.add(model);
        statusEl.className = 'success';
      },
      (progress) => {
        if (progress.lengthComputable) {
          const pct = Math.round((progress.loaded / progress.total) * 100);
          log(`Loading birb: ${pct}%`);
        }
      },
      (e) => {
        error('Failed to load birb model', e);
        // Keep placeholder, continue anyway
      }
    );

    // ============================================
    // STEP 5: Simple joystick
    // ============================================
    log('Step 5: Setting up joystick...');

    const joystickZone = document.getElementById('joystick-zone');
    const joystickEl = document.getElementById('joystick');
    const thumbEl = document.getElementById('joystick-thumb');

    let joystickInput = { x: 0, y: 0 };
    let joystickCenter = { x: 0, y: 0 };
    let activePointer = null;
    const JOYSTICK_RADIUS = 60;

    joystickZone.addEventListener('pointerdown', (e) => {
      if (activePointer !== null) return;
      activePointer = e.pointerId;
      joystickCenter = { x: e.clientX, y: e.clientY };
      joystickEl.style.left = (e.clientX - JOYSTICK_RADIUS) + 'px';
      joystickEl.style.top = (e.clientY - JOYSTICK_RADIUS) + 'px';
      joystickEl.classList.add('active');
      e.preventDefault();
    });

    window.addEventListener('pointermove', (e) => {
      if (e.pointerId !== activePointer) return;

      const dx = e.clientX - joystickCenter.x;
      const dy = e.clientY - joystickCenter.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const maxDist = JOYSTICK_RADIUS;

      let clampedDx = dx;
      let clampedDy = dy;

      if (dist > maxDist) {
        clampedDx = (dx / dist) * maxDist;
        clampedDy = (dy / dist) * maxDist;
      }

      thumbEl.style.transform = `translate(${clampedDx}px, ${clampedDy}px)`;

      joystickInput.x = clampedDx / maxDist;
      joystickInput.y = clampedDy / maxDist;

      e.preventDefault();
    });

    const endJoystick = (e) => {
      if (e.pointerId !== activePointer) return;
      activePointer = null;
      joystickEl.classList.remove('active');
      thumbEl.style.transform = 'translate(0, 0)';
      joystickInput = { x: 0, y: 0 };
    };

    window.addEventListener('pointerup', endJoystick);
    window.addEventListener('pointercancel', endJoystick);

    log('Step 5 complete: Joystick ready');

    // ============================================
    // STEP 6: Simple flight physics
    // ============================================

    const state = {
      position: new THREE.Vector3(0, 5, 0),
      velocity: new THREE.Vector3(0, 0, 0),
      yaw: 0,
      pitch: 0,
      roll: 0
    };

    const FORWARD_SPEED = 3;
    const TURN_RATE = Math.PI / 2;
    const PITCH_RATE = Math.PI / 4;
    const GRAVITY = 0.5;
    const LIFT = 1.5;

    function updateFlight(dt) {
      // Smoothly apply inputs
      const targetYawRate = -joystickInput.x * TURN_RATE;
      const targetPitchRate = -joystickInput.y * PITCH_RATE;

      state.yaw += targetYawRate * dt;
      state.pitch = THREE.MathUtils.lerp(state.pitch, joystickInput.y * 0.5, dt * 3);
      state.roll = THREE.MathUtils.lerp(state.roll, -joystickInput.x * 0.4, dt * 4);

      // Calculate forward direction from yaw
      const forward = new THREE.Vector3(
        Math.sin(state.yaw),
        0,
        Math.cos(state.yaw)
      );

      // Velocity
      state.velocity.x = forward.x * FORWARD_SPEED;
      state.velocity.z = forward.z * FORWARD_SPEED;

      // Vertical: lift from pitch, minus gravity
      const lift = (-joystickInput.y) * LIFT;
      state.velocity.y = THREE.MathUtils.lerp(state.velocity.y, lift - GRAVITY, dt * 2);

      // Update position
      state.position.add(state.velocity.clone().multiplyScalar(dt));

      // Keep above ground
      if (state.position.y < 1) {
        state.position.y = 1;
        state.velocity.y = Math.max(0, state.velocity.y);
      }

      // Apply to birb
      birb.position.copy(state.position);
      birb.rotation.set(state.pitch, -state.yaw, state.roll, 'YXZ');
    }

    // ============================================
    // STEP 7: Camera follow
    // ============================================

    const cameraOffset = new THREE.Vector3(0, 2, 6);

    function updateCamera(dt) {
      // Follow behind birb
      const behind = new THREE.Vector3(0, 0, 1).applyAxisAngle(
        new THREE.Vector3(0, 1, 0),
        -state.yaw
      );

      const targetPos = state.position.clone()
        .add(behind.multiplyScalar(5))
        .add(new THREE.Vector3(0, 2, 0));

      camera.position.lerp(targetPos, dt * 3);
      camera.lookAt(state.position);
    }

    // ============================================
    // STEP 8: Animation loop
    // ============================================
    log('Step 6-8: Starting game loop...');

    let lastTime = performance.now();

    function animate(time) {
      const dt = Math.min((time - lastTime) / 1000, 0.1);
      lastTime = time;

      updateFlight(dt);
      updateCamera(dt);

      // Update HUD
      const speed = Math.sqrt(
        state.velocity.x ** 2 + state.velocity.z ** 2
      );
      document.getElementById('speed').textContent = speed.toFixed(1);
      document.getElementById('alt').textContent = state.position.y.toFixed(1);

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    // Handle resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Start
    animate(performance.now());

    log('All systems go! Touch left side to control.');
    statusEl.className = 'success';

    // Hide status after 3 seconds if successful
    setTimeout(() => {
      if (statusEl.className === 'success') {
        statusEl.style.opacity = '0.3';
      }
    }, 3000);

  </script>
</body>
</html>
