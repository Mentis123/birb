<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>3D Test - AR Shooter</title>
    <link rel="stylesheet" href="css/style.css">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #0a0a0a;
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .back-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            text-decoration: none;
            border-radius: 8px;
            font-size: 0.9em;
            z-index: 10;
        }

        .info-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 0.85em;
            font-family: monospace;
            z-index: 10;
        }

        .info-panel div {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-btn">← Back</a>

    <canvas id="canvas"></canvas>

    <div class="crosshair"></div>

    <div class="info-panel">
        <div><strong>3D Rendering Test</strong></div>
        <div id="fps">FPS: --</div>
        <div id="objects">Objects: --</div>
        <div id="renderer">Renderer: --</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="js/scene.js"></script>
    <script>
        const canvas = document.getElementById('canvas');
        const fpsDiv = document.getElementById('fps');
        const objectsDiv = document.getElementById('objects');
        const rendererDiv = document.getElementById('renderer');

        let scene, camera, renderer;
        let cubes = [];
        const CUBE_COUNT = 8;

        // FPS counter
        let frameCount = 0;
        let lastTime = performance.now();
        let fps = 0;

        function initScene() {
            // Scene
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(
                70, // FOV - typical for mobile AR
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 0, 0);

            // Renderer with transparent background
            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                alpha: true,
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Optimize for mobile

            rendererDiv.textContent = `Renderer: WebGL ${renderer.capabilities.isWebGL2 ? '2' : '1'}`;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            scene.add(directionalLight);

            // Create target cubes at various positions
            createTargetCubes();

            // Handle resize
            window.addEventListener('resize', onWindowResize);

            // Start animation loop
            animate();
        }

        function createTargetCubes() {
            const geometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);

            for (let i = 0; i < CUBE_COUNT; i++) {
                // Random color
                const color = new THREE.Color();
                color.setHSL(Math.random(), 0.7, 0.6);

                const material = new THREE.MeshPhongMaterial({
                    color: color,
                    shininess: 80
                });

                const cube = new THREE.Mesh(geometry, material);

                // Position cubes in a hemisphere in front of camera
                const distance = 2 + Math.random() * 3; // 2-5 units away
                const angleH = (Math.random() - 0.5) * Math.PI * 0.8; // ±72 degrees horizontal
                const angleV = (Math.random() - 0.5) * Math.PI * 0.6; // ±54 degrees vertical

                cube.position.x = Math.sin(angleH) * Math.cos(angleV) * distance;
                cube.position.y = Math.sin(angleV) * distance;
                cube.position.z = -Math.cos(angleH) * Math.cos(angleV) * distance;

                // Random rotation
                cube.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );

                // Store initial position for animation
                cube.userData = {
                    initialPos: cube.position.clone(),
                    floatOffset: Math.random() * Math.PI * 2,
                    floatSpeed: 0.5 + Math.random() * 0.5,
                    rotSpeed: {
                        x: (Math.random() - 0.5) * 0.02,
                        y: (Math.random() - 0.5) * 0.02,
                        z: (Math.random() - 0.5) * 0.02
                    }
                };

                // Add edges for better visibility
                const edges = new THREE.EdgesGeometry(geometry);
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
                const wireframe = new THREE.LineSegments(edges, lineMaterial);
                cube.add(wireframe);

                scene.add(cube);
                cubes.push(cube);
            }

            objectsDiv.textContent = `Objects: ${cubes.length}`;
        }

        function animate(currentTime = 0) {
            requestAnimationFrame(animate);

            // Update FPS
            frameCount++;
            if (currentTime - lastTime >= 1000) {
                fps = frameCount;
                fpsDiv.textContent = `FPS: ${fps}`;
                fpsDiv.style.color = fps >= 30 ? '#4CAF50' : fps >= 20 ? '#FF9800' : '#f44336';
                frameCount = 0;
                lastTime = currentTime;
            }

            // Animate cubes
            const time = currentTime * 0.001; // Convert to seconds

            cubes.forEach(cube => {
                // Floating animation (sine wave)
                const offset = cube.userData.floatOffset;
                const speed = cube.userData.floatSpeed;
                const floatAmount = Math.sin(time * speed + offset) * 0.1;

                cube.position.y = cube.userData.initialPos.y + floatAmount;

                // Slow rotation
                cube.rotation.x += cube.userData.rotSpeed.x;
                cube.rotation.y += cube.userData.rotSpeed.y;
                cube.rotation.z += cube.userData.rotSpeed.z;
            });

            // Render
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Check WebGL support
        function checkWebGLSupport() {
            const testCanvas = document.createElement('canvas');
            const gl = testCanvas.getContext('webgl') || testCanvas.getContext('experimental-webgl');

            if (!gl) {
                alert('WebGL not supported! 3D rendering will not work.');
                return false;
            }
            return true;
        }

        // Initialize
        if (checkWebGLSupport()) {
            initScene();
        }

        // Manual camera controls for testing (drag to rotate camera)
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;

            camera.rotation.y += deltaX * 0.005;
            camera.rotation.x += deltaY * 0.005;

            // Clamp vertical rotation
            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));

            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        // Touch controls for mobile
        let touchStartX = 0;
        let touchStartY = 0;

        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            if (e.touches.length === 1) {
                const deltaX = e.touches[0].clientX - touchStartX;
                const deltaY = e.touches[0].clientY - touchStartY;

                camera.rotation.y += deltaX * 0.005;
                camera.rotation.x += deltaY * 0.005;

                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));

                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }
            e.preventDefault();
        }, { passive: false });
    </script>
</body>
</html>
